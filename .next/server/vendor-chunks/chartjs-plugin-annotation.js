"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chartjs-plugin-annotation";
exports.ids = ["vendor-chunks/chartjs-plugin-annotation"];
exports.modules = {

/***/ "(ssr)/./node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ annotation)\n/* harmony export */ });\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.dataset.js\");\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chart.js/helpers */ \"(ssr)/./node_modules/chart.js/helpers/helpers.js\");\n/*!\n* chartjs-plugin-annotation v3.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2024 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */ \n\n/**\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */ const interaction = {\n    modes: {\n        /**\n     * Point mode returns all elements that hit test based on the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @return {AnnotationElement[]} - elements that are found\n     */ point (visibleElements, event) {\n            return filterElements(visibleElements, event, {\n                intersect: true\n            });\n        },\n        /**\n     * Nearest mode returns the element closest to the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\n     */ nearest (visibleElements, event, options) {\n            return getNearestItem(visibleElements, event, options);\n        },\n        /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */ x (visibleElements, event, options) {\n            return filterElements(visibleElements, event, {\n                intersect: options.intersect,\n                axis: \"x\"\n            });\n        },\n        /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */ y (visibleElements, event, options) {\n            return filterElements(visibleElements, event, {\n                intersect: options.intersect,\n                axis: \"y\"\n            });\n        }\n    }\n};\n/**\n * Returns all elements that hit test based on the event position\n * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n * @param {ChartEvent} event - the event we are find things at\n * @param {Object} options - interaction options to use\n * @return {AnnotationElement[]} - elements that are found\n */ function getElements(visibleElements, event, options) {\n    const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n    return mode(visibleElements, event, options);\n}\nfunction inRangeByAxis(element, event, axis) {\n    if (axis !== \"x\" && axis !== \"y\") {\n        return element.inRange(event.x, event.y, \"x\", true) || element.inRange(event.x, event.y, \"y\", true);\n    }\n    return element.inRange(event.x, event.y, axis, true);\n}\nfunction getPointByAxis(event, center, axis) {\n    if (axis === \"x\") {\n        return {\n            x: event.x,\n            y: center.y\n        };\n    } else if (axis === \"y\") {\n        return {\n            x: center.x,\n            y: event.y\n        };\n    }\n    return center;\n}\nfunction filterElements(visibleElements, event, options) {\n    return visibleElements.filter((element)=>options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\nfunction getNearestItem(visibleElements, event, options) {\n    let minDistance = Number.POSITIVE_INFINITY;\n    return filterElements(visibleElements, event, options).reduce((nearestItems, element)=>{\n        const center = element.getCenterPoint();\n        const evenPoint = getPointByAxis(event, center, options.axis);\n        const distance = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.distanceBetweenPoints)(event, evenPoint);\n        if (distance < minDistance) {\n            nearestItems = [\n                element\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            // Can have multiple items at the same distance in which case we sort by size\n            nearestItems.push(element);\n        }\n        return nearestItems;\n    }, []).sort((a, b)=>a._index - b._index).slice(0, 1); // return only the top item;\n}\n/**\n * @typedef {import('chart.js').Point} Point\n */ /**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */ function rotated(point, center, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const cx = center.x;\n    const cy = center.y;\n    return {\n        x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n        y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n    };\n}\nconst isOlderPart = (act, req)=>req > act || act.length > req.length && act.slice(0, req.length) === req;\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */ const EPSILON = 0.001;\nconst clamp = (x, from, to)=>Math.min(to, Math.max(from, x));\n/**\n * @param {{value: number, start: number, end: number}} limit\n * @param {number} hitSize\n * @returns {boolean}\n */ const inLimit = (limit, hitSize)=>limit.value >= limit.start - hitSize && limit.value <= limit.end + hitSize;\n/**\n * @param {Object} obj\n * @param {number} from\n * @param {number} to\n * @returns {Object}\n */ function clampAll(obj, from, to) {\n    for (const key of Object.keys(obj)){\n        obj[key] = clamp(obj[key], from, to);\n    }\n    return obj;\n}\n/**\n * @param {Point} point\n * @param {Point} center\n * @param {number} radius\n * @param {number} hitSize\n * @returns {boolean}\n */ function inPointRange(point, center, radius, hitSize) {\n    if (!point || !center || radius <= 0) {\n        return false;\n    }\n    return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hitSize, 2);\n}\n/**\n * @param {Point} point\n * @param {{x: number, y: number, x2: number, y2: number}} rect\n * @param {InteractionAxis} axis\n * @param {{borderWidth: number, hitTolerance: number}} hitsize\n * @returns {boolean}\n */ function inBoxRange(point, { x, y, x2, y2 }, axis, { borderWidth, hitTolerance }) {\n    const hitSize = (borderWidth + hitTolerance) / 2;\n    const inRangeX = point.x >= x - hitSize - EPSILON && point.x <= x2 + hitSize + EPSILON;\n    const inRangeY = point.y >= y - hitSize - EPSILON && point.y <= y2 + hitSize + EPSILON;\n    if (axis === \"x\") {\n        return inRangeX;\n    } else if (axis === \"y\") {\n        return inRangeY;\n    }\n    return inRangeX && inRangeY;\n}\n/**\n * @param {Point} point\n * @param {rect: {x: number, y: number, x2: number, y2: number}, center: {x: number, y: number}} element\n * @param {InteractionAxis} axis\n * @param {{rotation: number, borderWidth: number, hitTolerance: number}}\n * @returns {boolean}\n */ function inLabelRange(point, { rect, center }, axis, { rotation, borderWidth, hitTolerance }) {\n    const rotPoint = rotated(point, center, (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(-rotation));\n    return inBoxRange(rotPoint, rect, axis, {\n        borderWidth,\n        hitTolerance\n    });\n}\n/**\n * @param {AnnotationElement} element\n * @param {boolean} useFinalPosition\n * @returns {Point}\n */ function getElementCenterPoint(element, useFinalPosition) {\n    const { centerX, centerY } = element.getProps([\n        \"centerX\",\n        \"centerY\"\n    ], useFinalPosition);\n    return {\n        x: centerX,\n        y: centerY\n    };\n}\n/**\n * @param {string} pkg\n * @param {string} min\n * @param {string} ver\n * @param {boolean} [strict=true]\n * @returns {boolean}\n */ function requireVersion(pkg, min, ver, strict = true) {\n    const parts = ver.split(\".\");\n    let i = 0;\n    for (const req of min.split(\".\")){\n        const act = parts[i++];\n        if (parseInt(req, 10) < parseInt(act, 10)) {\n            break;\n        }\n        if (isOlderPart(act, req)) {\n            if (strict) {\n                throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nconst isPercentString = (s)=>typeof s === \"string\" && s.endsWith(\"%\");\nconst toPercent = (s)=>parseFloat(s) / 100;\nconst toPositivePercent = (s)=>clamp(toPercent(s), 0, 1);\nconst boxAppering = (x, y)=>({\n        x,\n        y,\n        x2: x,\n        y2: y,\n        width: 0,\n        height: 0\n    });\nconst defaultInitAnimation = {\n    box: (properties)=>boxAppering(properties.centerX, properties.centerY),\n    doughnutLabel: (properties)=>boxAppering(properties.centerX, properties.centerY),\n    ellipse: (properties)=>({\n            centerX: properties.centerX,\n            centerY: properties.centerX,\n            radius: 0,\n            width: 0,\n            height: 0\n        }),\n    label: (properties)=>boxAppering(properties.centerX, properties.centerY),\n    line: (properties)=>boxAppering(properties.x, properties.y),\n    point: (properties)=>({\n            centerX: properties.centerX,\n            centerY: properties.centerY,\n            radius: 0,\n            width: 0,\n            height: 0\n        }),\n    polygon: (properties)=>boxAppering(properties.centerX, properties.centerY)\n};\n/**\n * @typedef { import('chart.js').FontSpec } FontSpec\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').Padding } Padding\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\n */ /**\n * @param {number} size\n * @param {number|string} position\n * @returns {number}\n */ function getRelativePosition(size, position) {\n    if (position === \"start\") {\n        return 0;\n    }\n    if (position === \"end\") {\n        return size;\n    }\n    if (isPercentString(position)) {\n        return toPositivePercent(position) * size;\n    }\n    return size / 2;\n}\n/**\n * @param {number} size\n * @param {number|string} value\n * @param {boolean} [positivePercent=true]\n * @returns {number}\n */ function getSize(size, value, positivePercent = true) {\n    if (typeof value === \"number\") {\n        return value;\n    } else if (isPercentString(value)) {\n        return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\n    }\n    return size;\n}\n/**\n * @param {{x: number, width: number}} size\n * @param {CoreLabelOptions} options\n * @returns {number}\n */ function calculateTextAlignment(size, options) {\n    const { x, width } = size;\n    const textAlign = options.textAlign;\n    if (textAlign === \"center\") {\n        return x + width / 2;\n    } else if (textAlign === \"end\" || textAlign === \"right\") {\n        return x + width;\n    }\n    return x;\n}\n/**\n * @param {Point} point\n * @param {{height: number, width: number}} labelSize\n * @param {{borderWidth: number, position: {LabelPositionObject|string}, xAdjust: number, yAdjust: number}} options\n * @param {Padding|undefined} padding\n * @returns {{x: number, y: number, x2: number, y2: number, height: number, width: number, centerX: number, centerY: number}}\n */ function measureLabelRectangle(point, labelSize, { borderWidth, position, xAdjust, yAdjust }, padding) {\n    const hasPadding = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(padding);\n    const width = labelSize.width + (hasPadding ? padding.width : 0) + borderWidth;\n    const height = labelSize.height + (hasPadding ? padding.height : 0) + borderWidth;\n    const positionObj = toPosition(position);\n    const x = calculateLabelPosition$1(point.x, width, xAdjust, positionObj.x);\n    const y = calculateLabelPosition$1(point.y, height, yAdjust, positionObj.y);\n    return {\n        x,\n        y,\n        x2: x + width,\n        y2: y + height,\n        width,\n        height,\n        centerX: x + width / 2,\n        centerY: y + height / 2\n    };\n}\n/**\n * @param {LabelPositionObject|string} value\n * @param {string|number} defaultValue\n * @returns {LabelPositionObject}\n */ function toPosition(value, defaultValue = \"center\") {\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {\n        return {\n            x: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)(value.x, defaultValue),\n            y: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)(value.y, defaultValue)\n        };\n    }\n    value = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)(value, defaultValue);\n    return {\n        x: value,\n        y: value\n    };\n}\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {boolean}\n */ const shouldFit = (options, fitRatio)=>options && options.autoFit && fitRatio < 1;\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {FontSpec[]}\n */ function toFonts(options, fitRatio) {\n    const optFont = options.font;\n    const fonts = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(optFont) ? optFont : [\n        optFont\n    ];\n    if (shouldFit(options, fitRatio)) {\n        return fonts.map(function(f) {\n            const font = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toFont)(f);\n            font.size = Math.floor(f.size * fitRatio);\n            font.lineHeight = f.lineHeight;\n            return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toFont)(font);\n        });\n    }\n    return fonts.map((f)=>(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toFont)(f));\n}\n/**\n * @param {AnnotationPointCoordinates} options\n * @returns {boolean}\n */ function isBoundToPoint(options) {\n    return options && ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(options.xValue) || (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(options.yValue));\n}\nfunction calculateLabelPosition$1(start, size, adjust = 0, position) {\n    return start - getRelativePosition(size, position) + adjust;\n}\n/**\n * @param {Chart} chart\n * @param {AnnotationBoxModel} properties\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationElement}\n */ function initAnimationProperties(chart, properties, options) {\n    const initAnim = options.init;\n    if (!initAnim) {\n        return;\n    } else if (initAnim === true) {\n        return applyDefault(properties, options);\n    }\n    return execCallback(chart, properties, options);\n}\n/**\n * @param {Object} options\n * @param {Array} hooks\n * @param {Object} hooksContainer\n * @returns {boolean}\n */ function loadHooks(options, hooks, hooksContainer) {\n    let activated = false;\n    hooks.forEach((hook)=>{\n        if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(options[hook])) {\n            activated = true;\n            hooksContainer[hook] = options[hook];\n        } else if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(hooksContainer[hook])) {\n            delete hooksContainer[hook];\n        }\n    });\n    return activated;\n}\nfunction applyDefault(properties, options) {\n    const type = options.type || \"line\";\n    return defaultInitAnimation[type](properties);\n}\nfunction execCallback(chart, properties, options) {\n    const result = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(options.init, [\n        {\n            chart,\n            properties,\n            options\n        }\n    ]);\n    if (result === true) {\n        return applyDefault(properties, options);\n    } else if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(result)) {\n        return result;\n    }\n}\nconst widthCache = new Map();\nconst notRadius = (radius)=>isNaN(radius) || radius <= 0;\nconst fontsKey = (fonts)=>fonts.reduce(function(prev, item) {\n        prev += item.string;\n        return prev;\n    }, \"\");\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n */ /**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */ function isImageOrCanvas(content) {\n    if (content && typeof content === \"object\") {\n        const type = content.toString();\n        return type === \"[object HTMLImageElement]\" || type === \"[object HTMLCanvasElement]\";\n    }\n}\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Point} point - the point of translation\n * @param {number} rotation - rotation (in degrees) to apply\n */ function translate(ctx, { x, y }, rotation) {\n    if (rotation) {\n        ctx.translate(x, y);\n        ctx.rotate((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(rotation));\n        ctx.translate(-x, -y);\n    }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n * @returns {boolean|undefined}\n */ function setBorderStyle(ctx, options) {\n    if (options && options.borderWidth) {\n        ctx.lineCap = options.borderCapStyle || \"butt\";\n        ctx.setLineDash(options.borderDash);\n        ctx.lineDashOffset = options.borderDashOffset;\n        ctx.lineJoin = options.borderJoinStyle || \"miter\";\n        ctx.lineWidth = options.borderWidth;\n        ctx.strokeStyle = options.borderColor;\n        return true;\n    }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n */ function setShadowStyle(ctx, options) {\n    ctx.shadowColor = options.backgroundShadowColor;\n    ctx.shadowBlur = options.shadowBlur;\n    ctx.shadowOffsetX = options.shadowOffsetX;\n    ctx.shadowOffsetY = options.shadowOffsetY;\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CoreLabelOptions} options\n * @returns {{width: number, height: number}}\n */ function measureLabelSize(ctx, options) {\n    const content = options.content;\n    if (isImageOrCanvas(content)) {\n        const size = {\n            width: getSize(content.width, options.width),\n            height: getSize(content.height, options.height)\n        };\n        return size;\n    }\n    const fonts = toFonts(options);\n    const strokeWidth = options.textStrokeWidth;\n    const lines = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(content) ? content : [\n        content\n    ];\n    const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? \"-spriting\" : \"\");\n    if (!widthCache.has(mapKey)) {\n        widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\n    }\n    return widthCache.get(mapKey);\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {Object} options\n */ function drawBox(ctx, rect, options) {\n    const { x, y, width, height } = rect;\n    ctx.save();\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.beginPath();\n    (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.addRoundedRectPath)(ctx, {\n        x,\n        y,\n        w: width,\n        h: height,\n        radius: clampAll((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toTRBLCorners)(options.borderRadius), 0, Math.min(width, height) / 2)\n    });\n    ctx.closePath();\n    ctx.fill();\n    if (stroke) {\n        ctx.shadowColor = options.borderShadowColor;\n        ctx.stroke();\n    }\n    ctx.restore();\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n */ function drawLabel(ctx, rect, options, fitRatio) {\n    const content = options.content;\n    if (isImageOrCanvas(content)) {\n        ctx.save();\n        ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\n        ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n        ctx.restore();\n        return;\n    }\n    const labels = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(content) ? content : [\n        content\n    ];\n    const fonts = toFonts(options, fitRatio);\n    const optColor = options.color;\n    const colors = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(optColor) ? optColor : [\n        optColor\n    ];\n    const x = calculateTextAlignment(rect, options);\n    const y = rect.y + options.textStrokeWidth / 2;\n    ctx.save();\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = options.textAlign;\n    if (setTextStrokeStyle(ctx, options)) {\n        applyLabelDecoration(ctx, {\n            x,\n            y\n        }, labels, fonts);\n    }\n    applyLabelContent(ctx, {\n        x,\n        y\n    }, labels, {\n        fonts,\n        colors\n    });\n    ctx.restore();\n}\nfunction setTextStrokeStyle(ctx, options) {\n    if (options.textStrokeWidth > 0) {\n        // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n        ctx.lineJoin = \"round\";\n        ctx.miterLimit = 2;\n        ctx.lineWidth = options.textStrokeWidth;\n        ctx.strokeStyle = options.textStrokeColor;\n        return true;\n    }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{radius: number, options: PointAnnotationOptions}} element\n * @param {number} x\n * @param {number} y\n */ function drawPoint(ctx, element, x, y) {\n    const { radius, options } = element;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    let rad = (rotation || 0) * chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.RAD_PER_DEG;\n    if (isImageOrCanvas(style)) {\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.rotate(rad);\n        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n        ctx.restore();\n        return;\n    }\n    if (notRadius(radius)) {\n        return;\n    }\n    drawPointStyle(ctx, {\n        x,\n        y,\n        radius,\n        rotation,\n        style,\n        rad\n    });\n}\nfunction drawPointStyle(ctx, { x, y, radius, rotation, style, rad }) {\n    let xOffset, yOffset, size, cornerRadius;\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            ctx.arc(x, y, radius, 0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.TAU);\n            ctx.closePath();\n            break;\n        case \"triangle\":\n            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case \"rectRounded\":\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI) * size;\n            yOffset = Math.sin(rad + chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI) * size;\n            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI, rad - chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.HALF_PI);\n            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.HALF_PI, rad);\n            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.HALF_PI);\n            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.HALF_PI, rad + chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI);\n            ctx.closePath();\n            break;\n        case \"rect\":\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                ctx.rect(x - size, y - size, 2 * size, 2 * size);\n                break;\n            }\n            rad += chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI;\n        /* falls through */ case \"rectRot\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            ctx.closePath();\n            break;\n        case \"crossRot\":\n            rad += chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI;\n        /* falls through */ case \"cross\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"star\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            rad += chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI;\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"line\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case \"dash\":\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n            break;\n    }\n    ctx.fill();\n}\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\n    ctx.save();\n    const count = lines.length;\n    let width = 0;\n    let height = strokeWidth;\n    for(let i = 0; i < count; i++){\n        const font = fonts[Math.min(i, fonts.length - 1)];\n        ctx.font = font.string;\n        const text = lines[i];\n        width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n        height += font.lineHeight;\n    }\n    ctx.restore();\n    return {\n        width,\n        height\n    };\n}\nfunction applyLabelDecoration(ctx, { x, y }, labels, fonts) {\n    ctx.beginPath();\n    let lhs = 0;\n    labels.forEach(function(l, i) {\n        const f = fonts[Math.min(i, fonts.length - 1)];\n        const lh = f.lineHeight;\n        ctx.font = f.string;\n        ctx.strokeText(l, x, y + lh / 2 + lhs);\n        lhs += lh;\n    });\n    ctx.stroke();\n}\nfunction applyLabelContent(ctx, { x, y }, labels, { fonts, colors }) {\n    let lhs = 0;\n    labels.forEach(function(l, i) {\n        const c = colors[Math.min(i, colors.length - 1)];\n        const f = fonts[Math.min(i, fonts.length - 1)];\n        const lh = f.lineHeight;\n        ctx.beginPath();\n        ctx.font = f.string;\n        ctx.fillStyle = c;\n        ctx.fillText(l, x, y + lh / 2 + lhs);\n        lhs += lh;\n        ctx.fill();\n    });\n}\nfunction getOpacity(value, elementValue) {\n    const opacity = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value) ? value : elementValue;\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(opacity) ? clamp(opacity, 0, 1) : 1;\n}\nconst positions = [\n    \"left\",\n    \"bottom\",\n    \"top\",\n    \"right\"\n];\n/**\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */ /**\n * Drawa the callout component for labels.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {AnnotationElement} element - the label element\n */ function drawCallout(ctx, element) {\n    const { pointX, pointY, options } = element;\n    const callout = options.callout;\n    const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n    if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n        return;\n    }\n    ctx.save();\n    ctx.beginPath();\n    const stroke = setBorderStyle(ctx, callout);\n    if (!stroke) {\n        return ctx.restore();\n    }\n    const { separatorStart, separatorEnd } = getCalloutSeparatorCoord(element, calloutPosition);\n    const { sideStart, sideEnd } = getCalloutSideCoord(element, calloutPosition, separatorStart);\n    if (callout.margin > 0 || options.borderWidth === 0) {\n        ctx.moveTo(separatorStart.x, separatorStart.y);\n        ctx.lineTo(separatorEnd.x, separatorEnd.y);\n    }\n    ctx.moveTo(sideStart.x, sideStart.y);\n    ctx.lineTo(sideEnd.x, sideEnd.y);\n    const rotatedPoint = rotated({\n        x: pointX,\n        y: pointY\n    }, element.getCenterPoint(), (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(-element.rotation));\n    ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n    ctx.stroke();\n    ctx.restore();\n}\nfunction getCalloutSeparatorCoord(element, position) {\n    const { x, y, x2, y2 } = element;\n    const adjust = getCalloutSeparatorAdjust(element, position);\n    let separatorStart, separatorEnd;\n    if (position === \"left\" || position === \"right\") {\n        separatorStart = {\n            x: x + adjust,\n            y\n        };\n        separatorEnd = {\n            x: separatorStart.x,\n            y: y2\n        };\n    } else {\n        //  position 'top' or 'bottom'\n        separatorStart = {\n            x,\n            y: y + adjust\n        };\n        separatorEnd = {\n            x: x2,\n            y: separatorStart.y\n        };\n    }\n    return {\n        separatorStart,\n        separatorEnd\n    };\n}\nfunction getCalloutSeparatorAdjust(element, position) {\n    const { width, height, options } = element;\n    const adjust = options.callout.margin + options.borderWidth / 2;\n    if (position === \"right\") {\n        return width + adjust;\n    } else if (position === \"bottom\") {\n        return height + adjust;\n    }\n    return -adjust;\n}\nfunction getCalloutSideCoord(element, position, separatorStart) {\n    const { y, width, height, options } = element;\n    const start = options.callout.start;\n    const side = getCalloutSideAdjust(position, options.callout);\n    let sideStart, sideEnd;\n    if (position === \"left\" || position === \"right\") {\n        sideStart = {\n            x: separatorStart.x,\n            y: y + getSize(height, start)\n        };\n        sideEnd = {\n            x: sideStart.x + side,\n            y: sideStart.y\n        };\n    } else {\n        //  position 'top' or 'bottom'\n        sideStart = {\n            x: separatorStart.x + getSize(width, start),\n            y: separatorStart.y\n        };\n        sideEnd = {\n            x: sideStart.x,\n            y: sideStart.y + side\n        };\n    }\n    return {\n        sideStart,\n        sideEnd\n    };\n}\nfunction getCalloutSideAdjust(position, options) {\n    const side = options.side;\n    if (position === \"left\" || position === \"top\") {\n        return -side;\n    }\n    return side;\n}\nfunction resolveCalloutPosition(element, options) {\n    const position = options.position;\n    if (positions.includes(position)) {\n        return position;\n    }\n    return resolveCalloutAutoPosition(element, options);\n}\nfunction resolveCalloutAutoPosition(element, options) {\n    const { x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation } = element;\n    const center = {\n        x: centerX,\n        y: centerY\n    };\n    const start = options.start;\n    const xAdjust = getSize(width, start);\n    const yAdjust = getSize(height, start);\n    const xPoints = [\n        x,\n        x + xAdjust,\n        x + xAdjust,\n        x2\n    ];\n    const yPoints = [\n        y + yAdjust,\n        y2,\n        y,\n        y2\n    ];\n    const result = [];\n    for(let index = 0; index < 4; index++){\n        const rotatedPoint = rotated({\n            x: xPoints[index],\n            y: yPoints[index]\n        }, center, (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(rotation));\n        result.push({\n            position: positions[index],\n            distance: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.distanceBetweenPoints)(rotatedPoint, {\n                x: pointX,\n                y: pointY\n            })\n        });\n    }\n    return result.sort((a, b)=>a.distance - b.distance)[0].position;\n}\nfunction isPointInRange(element, callout, position) {\n    const { pointX, pointY } = element;\n    const margin = callout.margin;\n    let x = pointX;\n    let y = pointY;\n    if (position === \"left\") {\n        x += margin;\n    } else if (position === \"right\") {\n        x -= margin;\n    } else if (position === \"top\") {\n        y += margin;\n    } else if (position === \"bottom\") {\n        y -= margin;\n    }\n    return element.inRange(x, y);\n}\nconst limitedLineScale = {\n    xScaleID: {\n        min: \"xMin\",\n        max: \"xMax\",\n        start: \"left\",\n        end: \"right\",\n        startProp: \"x\",\n        endProp: \"x2\"\n    },\n    yScaleID: {\n        min: \"yMin\",\n        max: \"yMax\",\n        start: \"bottom\",\n        end: \"top\",\n        startProp: \"y\",\n        endProp: \"y2\"\n    }\n};\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\n */ /**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */ function scaleValue(scale, value, fallback) {\n    value = typeof value === \"number\" ? value : scale.parse(value);\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFinite)(value) ? scale.getPixelForValue(value) : fallback;\n}\n/**\n * Search the scale defined in chartjs by the axis related to the annotation options key.\n * @param {{ [key: string]: Scale }} scales\n * @param {CoreAnnotationOptions} options\n * @param {string} key\n * @returns {string}\n */ function retrieveScaleID(scales, options, key) {\n    const scaleID = options[key];\n    if (scaleID || key === \"scaleID\") {\n        return scaleID;\n    }\n    const axis = key.charAt(0);\n    const axes = Object.values(scales).filter((scale)=>scale.axis && scale.axis === axis);\n    if (axes.length) {\n        return axes[0].id;\n    }\n    return axis;\n}\n/**\n * @param {Scale} scale\n * @param {{min: number, max: number, start: number, end: number}} options\n * @returns {{start: number, end: number}|undefined}\n */ function getDimensionByScale(scale, options) {\n    if (scale) {\n        const reverse = scale.options.reverse;\n        const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n        const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n        return {\n            start,\n            end\n        };\n    }\n}\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */ function getChartPoint(chart, options) {\n    const { chartArea, scales } = chart;\n    const xScale = scales[retrieveScaleID(scales, options, \"xScaleID\")];\n    const yScale = scales[retrieveScaleID(scales, options, \"yScaleID\")];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n    if (xScale) {\n        x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n    }\n    if (yScale) {\n        y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n    }\n    return {\n        x,\n        y\n    };\n}\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */ function resolveBoxProperties(chart, options) {\n    const scales = chart.scales;\n    const xScale = scales[retrieveScaleID(scales, options, \"xScaleID\")];\n    const yScale = scales[retrieveScaleID(scales, options, \"yScaleID\")];\n    if (!xScale && !yScale) {\n        return {};\n    }\n    let { left: x, right: x2 } = xScale || chart.chartArea;\n    let { top: y, bottom: y2 } = yScale || chart.chartArea;\n    const xDim = getChartDimensionByScale(xScale, {\n        min: options.xMin,\n        max: options.xMax,\n        start: x,\n        end: x2\n    });\n    x = xDim.start;\n    x2 = xDim.end;\n    const yDim = getChartDimensionByScale(yScale, {\n        min: options.yMin,\n        max: options.yMax,\n        start: y2,\n        end: y\n    });\n    y = yDim.start;\n    y2 = yDim.end;\n    return {\n        x,\n        y,\n        x2,\n        y2,\n        width: x2 - x,\n        height: y2 - y,\n        centerX: x + (x2 - x) / 2,\n        centerY: y + (y2 - y) / 2\n    };\n}\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */ function resolvePointProperties(chart, options) {\n    if (!isBoundToPoint(options)) {\n        const box = resolveBoxProperties(chart, options);\n        let radius = options.radius;\n        if (!radius || isNaN(radius)) {\n            radius = Math.min(box.width, box.height) / 2;\n            options.radius = radius;\n        }\n        const size = radius * 2;\n        const adjustCenterX = box.centerX + options.xAdjust;\n        const adjustCenterY = box.centerY + options.yAdjust;\n        return {\n            x: adjustCenterX - radius,\n            y: adjustCenterY - radius,\n            x2: adjustCenterX + radius,\n            y2: adjustCenterY + radius,\n            centerX: adjustCenterX,\n            centerY: adjustCenterY,\n            width: size,\n            height: size,\n            radius\n        };\n    }\n    return getChartCircle(chart, options);\n}\n/**\n * @param {Chart} chart\n * @param {LineAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */ function resolveLineProperties(chart, options) {\n    const { scales, chartArea } = chart;\n    const scale = scales[options.scaleID];\n    const area = {\n        x: chartArea.left,\n        y: chartArea.top,\n        x2: chartArea.right,\n        y2: chartArea.bottom\n    };\n    if (scale) {\n        resolveFullLineProperties(scale, area, options);\n    } else {\n        resolveLimitedLineProperties(scales, area, options);\n    }\n    return area;\n}\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @param {boolean} [centerBased=false]\n * @returns {AnnotationBoxModel}\n */ function resolveBoxAndLabelProperties(chart, options) {\n    const properties = resolveBoxProperties(chart, options);\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    properties.elements = [\n        {\n            type: \"label\",\n            optionScope: \"label\",\n            properties: resolveLabelElementProperties$1(chart, properties, options),\n            initProperties: properties.initProperties\n        }\n    ];\n    return properties;\n}\nfunction getChartCircle(chart, options) {\n    const point = getChartPoint(chart, options);\n    const size = options.radius * 2;\n    return {\n        x: point.x - options.radius + options.xAdjust,\n        y: point.y - options.radius + options.yAdjust,\n        x2: point.x + options.radius + options.xAdjust,\n        y2: point.y + options.radius + options.yAdjust,\n        centerX: point.x + options.xAdjust,\n        centerY: point.y + options.yAdjust,\n        radius: options.radius,\n        width: size,\n        height: size\n    };\n}\nfunction getChartDimensionByScale(scale, options) {\n    const result = getDimensionByScale(scale, options) || options;\n    return {\n        start: Math.min(result.start, result.end),\n        end: Math.max(result.start, result.end)\n    };\n}\nfunction resolveFullLineProperties(scale, area, options) {\n    const min = scaleValue(scale, options.value, NaN);\n    const max = scaleValue(scale, options.endValue, min);\n    if (scale.isHorizontal()) {\n        area.x = min;\n        area.x2 = max;\n    } else {\n        area.y = min;\n        area.y2 = max;\n    }\n}\nfunction resolveLimitedLineProperties(scales, area, options) {\n    for (const scaleId of Object.keys(limitedLineScale)){\n        const scale = scales[retrieveScaleID(scales, options, scaleId)];\n        if (scale) {\n            const { min, max, start, end, startProp, endProp } = limitedLineScale[scaleId];\n            const dim = getDimensionByScale(scale, {\n                min: options[min],\n                max: options[max],\n                start: scale[start],\n                end: scale[end]\n            });\n            area[startProp] = dim.start;\n            area[endProp] = dim.end;\n        }\n    }\n}\nfunction calculateX({ properties, options }, labelSize, position, padding) {\n    const { x: start, x2: end, width: size } = properties;\n    return calculatePosition({\n        start,\n        end,\n        size,\n        borderWidth: options.borderWidth\n    }, {\n        position: position.x,\n        padding: {\n            start: padding.left,\n            end: padding.right\n        },\n        adjust: options.label.xAdjust,\n        size: labelSize.width\n    });\n}\nfunction calculateY({ properties, options }, labelSize, position, padding) {\n    const { y: start, y2: end, height: size } = properties;\n    return calculatePosition({\n        start,\n        end,\n        size,\n        borderWidth: options.borderWidth\n    }, {\n        position: position.y,\n        padding: {\n            start: padding.top,\n            end: padding.bottom\n        },\n        adjust: options.label.yAdjust,\n        size: labelSize.height\n    });\n}\nfunction calculatePosition(boxOpts, labelOpts) {\n    const { start, end, borderWidth } = boxOpts;\n    const { position, padding: { start: padStart, end: padEnd }, adjust } = labelOpts;\n    const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n    return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n    const label = options.label;\n    label.backgroundColor = \"transparent\";\n    label.callout.display = false;\n    const position = toPosition(label.position);\n    const padding = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)(label.padding);\n    const labelSize = measureLabelSize(chart.ctx, label);\n    const x = calculateX({\n        properties,\n        options\n    }, labelSize, position, padding);\n    const y = calculateY({\n        properties,\n        options\n    }, labelSize, position, padding);\n    const width = labelSize.width + padding.width;\n    const height = labelSize.height + padding.height;\n    return {\n        x,\n        y,\n        x2: x + width,\n        y2: y + height,\n        width,\n        height,\n        centerX: x + width / 2,\n        centerY: y + height / 2,\n        rotation: label.rotation\n    };\n}\nconst moveHooks = [\n    \"enter\",\n    \"leave\"\n];\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */ const eventHooks = moveHooks.concat(\"click\");\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */ function updateListeners(chart, state, options) {\n    state.listened = loadHooks(options, eventHooks, state.listeners);\n    state.moveListened = false;\n    moveHooks.forEach((hook)=>{\n        if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(options[hook])) {\n            state.moveListened = true;\n        }\n    });\n    if (!state.listened || !state.moveListened) {\n        state.annotations.forEach((scope)=>{\n            if (!state.listened && (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(scope.click)) {\n                state.listened = true;\n            }\n            if (!state.moveListened) {\n                moveHooks.forEach((hook)=>{\n                    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(scope[hook])) {\n                        state.listened = true;\n                        state.moveListened = true;\n                    }\n                });\n            }\n        });\n    }\n}\n/**\n * @param {Object} state\n * @param {ChartEvent} event\n * @param {AnnotationPluginOptions} options\n * @return {boolean|undefined}\n */ function handleEvent(state, event, options) {\n    if (state.listened) {\n        switch(event.type){\n            case \"mousemove\":\n            case \"mouseout\":\n                return handleMoveEvents(state, event, options);\n            case \"click\":\n                return handleClickEvents(state, event, options);\n        }\n    }\n}\nfunction handleMoveEvents(state, event, options) {\n    if (!state.moveListened) {\n        return;\n    }\n    let elements;\n    if (event.type === \"mousemove\") {\n        elements = getElements(state.visibleElements, event, options.interaction);\n    } else {\n        elements = [];\n    }\n    const previous = state.hovered;\n    state.hovered = elements;\n    const context = {\n        state,\n        event\n    };\n    let changed = dispatchMoveEvents(context, \"leave\", previous, elements);\n    return dispatchMoveEvents(context, \"enter\", elements, previous) || changed;\n}\nfunction dispatchMoveEvents({ state, event }, hook, elements, checkElements) {\n    let changed;\n    for (const element of elements){\n        if (checkElements.indexOf(element) < 0) {\n            changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n        }\n    }\n    return changed;\n}\nfunction handleClickEvents(state, event, options) {\n    const listeners = state.listeners;\n    const elements = getElements(state.visibleElements, event, options.interaction);\n    let changed;\n    for (const element of elements){\n        changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n    }\n    return changed;\n}\nfunction dispatchEvent(handler, element, event) {\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(handler, [\n        element.$context,\n        event\n    ]) === true;\n}\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */ const elementHooks = [\n    \"afterDraw\",\n    \"beforeDraw\"\n];\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */ function updateHooks(chart, state, options) {\n    const visibleElements = state.visibleElements;\n    state.hooked = loadHooks(options, elementHooks, state.hooks);\n    if (!state.hooked) {\n        visibleElements.forEach((scope)=>{\n            if (!state.hooked) {\n                elementHooks.forEach((hook)=>{\n                    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(scope.options[hook])) {\n                        state.hooked = true;\n                    }\n                });\n            }\n        });\n    }\n}\n/**\n * @param {Object} state\n * @param {AnnotationElement} element\n * @param {string} hook\n */ function invokeHook(state, element, hook) {\n    if (state.hooked) {\n        const callbackHook = element.options[hook] || state.hooks[hook];\n        return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(callbackHook, [\n            element.$context\n        ]);\n    }\n}\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n */ /**\n * @param {Chart} chart\n * @param {Scale} scale\n * @param {CoreAnnotationOptions[]} annotations\n */ function adjustScaleRange(chart, scale, annotations) {\n    const range = getScaleLimits(chart.scales, scale, annotations);\n    let changed = changeScaleLimit(scale, range, \"min\", \"suggestedMin\");\n    changed = changeScaleLimit(scale, range, \"max\", \"suggestedMax\") || changed;\n    if (changed && (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(scale.handleTickRangeOptions)) {\n        scale.handleTickRangeOptions();\n    }\n}\n/**\n * @param {CoreAnnotationOptions[]} annotations\n * @param {{ [key: string]: Scale }} scales\n */ function verifyScaleOptions(annotations, scales) {\n    for (const annotation of annotations){\n        verifyScaleIDs(annotation, scales);\n    }\n}\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isFinite)(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n        const changed = scale[limit] !== range[limit];\n        scale[limit] = range[limit];\n        return changed;\n    }\n}\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n    return (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(scaleOptions[limit]) || (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(scaleOptions[suggestedLimit]);\n}\nfunction verifyScaleIDs(annotation, scales) {\n    for (const key of [\n        \"scaleID\",\n        \"xScaleID\",\n        \"yScaleID\"\n    ]){\n        const scaleID = retrieveScaleID(scales, annotation, key);\n        if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n            console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n        }\n    }\n}\nfunction verifyProperties(annotation, key) {\n    if (key === \"scaleID\") {\n        return true;\n    }\n    const axis = key.charAt(0);\n    for (const prop of [\n        \"Min\",\n        \"Max\",\n        \"Value\"\n    ]){\n        if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(annotation[axis + prop])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScaleLimits(scales, scale, annotations) {\n    const axis = scale.axis;\n    const scaleID = scale.id;\n    const scaleIDOption = axis + \"ScaleID\";\n    const limits = {\n        min: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)(scale.min, Number.NEGATIVE_INFINITY),\n        max: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)(scale.max, Number.POSITIVE_INFINITY)\n    };\n    for (const annotation of annotations){\n        if (annotation.scaleID === scaleID) {\n            updateLimits(annotation, scale, [\n                \"value\",\n                \"endValue\"\n            ], limits);\n        } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n            updateLimits(annotation, scale, [\n                axis + \"Min\",\n                axis + \"Max\",\n                axis + \"Value\"\n            ], limits);\n        }\n    }\n    return limits;\n}\nfunction updateLimits(annotation, scale, props, limits) {\n    for (const prop of props){\n        const raw = annotation[prop];\n        if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(raw)) {\n            const value = scale.parse(raw);\n            limits.min = Math.min(limits.min, value);\n            limits.max = Math.max(limits.max, value);\n        }\n    }\n}\nclass BoxAnnotation extends chart_js__WEBPACK_IMPORTED_MODULE_1__.Element {\n    inRange(mouseX, mouseY, axis, useFinalPosition) {\n        const { x, y } = rotated({\n            x: mouseX,\n            y: mouseY\n        }, this.getCenterPoint(useFinalPosition), (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(-this.options.rotation));\n        return inBoxRange({\n            x,\n            y\n        }, this.getProps([\n            \"x\",\n            \"y\",\n            \"x2\",\n            \"y2\"\n        ], useFinalPosition), axis, this.options);\n    }\n    getCenterPoint(useFinalPosition) {\n        return getElementCenterPoint(this, useFinalPosition);\n    }\n    draw(ctx) {\n        ctx.save();\n        translate(ctx, this.getCenterPoint(), this.options.rotation);\n        drawBox(ctx, this, this.options);\n        ctx.restore();\n    }\n    get label() {\n        return this.elements && this.elements[0];\n    }\n    resolveElementProperties(chart, options) {\n        return resolveBoxAndLabelProperties(chart, options);\n    }\n}\nBoxAnnotation.id = \"boxAnnotation\";\nBoxAnnotation.defaults = {\n    adjustScaleRange: true,\n    backgroundShadowColor: \"transparent\",\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderRadius: 0,\n    borderShadowColor: \"transparent\",\n    borderWidth: 1,\n    display: true,\n    init: undefined,\n    hitTolerance: 0,\n    label: {\n        backgroundColor: \"transparent\",\n        borderWidth: 0,\n        callout: {\n            display: false\n        },\n        color: \"black\",\n        content: null,\n        display: false,\n        drawTime: undefined,\n        font: {\n            family: undefined,\n            lineHeight: undefined,\n            size: undefined,\n            style: undefined,\n            weight: \"bold\"\n        },\n        height: undefined,\n        hitTolerance: undefined,\n        opacity: undefined,\n        padding: 6,\n        position: \"center\",\n        rotation: undefined,\n        textAlign: \"start\",\n        textStrokeColor: undefined,\n        textStrokeWidth: 0,\n        width: undefined,\n        xAdjust: 0,\n        yAdjust: 0,\n        z: undefined\n    },\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    xMax: undefined,\n    xMin: undefined,\n    xScaleID: undefined,\n    yMax: undefined,\n    yMin: undefined,\n    yScaleID: undefined,\n    z: 0\n};\nBoxAnnotation.defaultRoutes = {\n    borderColor: \"color\",\n    backgroundColor: \"color\"\n};\nBoxAnnotation.descriptors = {\n    label: {\n        _fallback: true\n    }\n};\nclass DoughnutLabelAnnotation extends chart_js__WEBPACK_IMPORTED_MODULE_1__.Element {\n    inRange(mouseX, mouseY, axis, useFinalPosition) {\n        return inLabelRange({\n            x: mouseX,\n            y: mouseY\n        }, {\n            rect: this.getProps([\n                \"x\",\n                \"y\",\n                \"x2\",\n                \"y2\"\n            ], useFinalPosition),\n            center: this.getCenterPoint(useFinalPosition)\n        }, axis, {\n            rotation: this.rotation,\n            borderWidth: 0,\n            hitTolerance: this.options.hitTolerance\n        });\n    }\n    getCenterPoint(useFinalPosition) {\n        return getElementCenterPoint(this, useFinalPosition);\n    }\n    draw(ctx) {\n        const options = this.options;\n        if (!options.display || !options.content) {\n            return;\n        }\n        drawBackground(ctx, this);\n        ctx.save();\n        translate(ctx, this.getCenterPoint(), this.rotation);\n        drawLabel(ctx, this, options, this._fitRatio);\n        ctx.restore();\n    }\n    resolveElementProperties(chart, options) {\n        const meta = getDatasetMeta(chart, options);\n        if (!meta) {\n            return {};\n        }\n        const { controllerMeta, point, radius } = getControllerMeta(chart, options, meta);\n        let labelSize = measureLabelSize(chart.ctx, options);\n        const _fitRatio = getFitRatio(labelSize, radius);\n        if (shouldFit(options, _fitRatio)) {\n            labelSize = {\n                width: labelSize.width * _fitRatio,\n                height: labelSize.height * _fitRatio\n            };\n        }\n        const { position, xAdjust, yAdjust } = options;\n        const boxSize = measureLabelRectangle(point, labelSize, {\n            borderWidth: 0,\n            position,\n            xAdjust,\n            yAdjust\n        });\n        return {\n            initProperties: initAnimationProperties(chart, boxSize, options),\n            ...boxSize,\n            ...controllerMeta,\n            rotation: options.rotation,\n            _fitRatio\n        };\n    }\n}\nDoughnutLabelAnnotation.id = \"doughnutLabelAnnotation\";\nDoughnutLabelAnnotation.defaults = {\n    autoFit: true,\n    autoHide: true,\n    backgroundColor: \"transparent\",\n    backgroundShadowColor: \"transparent\",\n    borderColor: \"transparent\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderShadowColor: \"transparent\",\n    borderWidth: 0,\n    color: \"black\",\n    content: null,\n    display: true,\n    font: {\n        family: undefined,\n        lineHeight: undefined,\n        size: undefined,\n        style: undefined,\n        weight: undefined\n    },\n    height: undefined,\n    hitTolerance: 0,\n    init: undefined,\n    opacity: undefined,\n    position: \"center\",\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    spacing: 1,\n    textAlign: \"center\",\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0\n};\nDoughnutLabelAnnotation.defaultRoutes = {};\nfunction getDatasetMeta(chart, options) {\n    return chart.getSortedVisibleDatasetMetas().reduce(function(result, value) {\n        const controller = value.controller;\n        if (controller instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.DoughnutController && isControllerVisible(chart, options, value.data) && (!result || controller.innerRadius < result.controller.innerRadius) && controller.options.circumference >= 90) {\n            return value;\n        }\n        return result;\n    }, undefined);\n}\nfunction isControllerVisible(chart, options, elements) {\n    if (!options.autoHide) {\n        return true;\n    }\n    for(let i = 0; i < elements.length; i++){\n        if (!elements[i].hidden && chart.getDataVisibility(i)) {\n            return true;\n        }\n    }\n}\nfunction getControllerMeta({ chartArea }, options, meta) {\n    const { left, top, right, bottom } = chartArea;\n    const { innerRadius, offsetX, offsetY } = meta.controller;\n    const x = (left + right) / 2 + offsetX;\n    const y = (top + bottom) / 2 + offsetY;\n    const square = {\n        left: Math.max(x - innerRadius, left),\n        right: Math.min(x + innerRadius, right),\n        top: Math.max(y - innerRadius, top),\n        bottom: Math.min(y + innerRadius, bottom)\n    };\n    const point = {\n        x: (square.left + square.right) / 2,\n        y: (square.top + square.bottom) / 2\n    };\n    const space = options.spacing + options.borderWidth / 2;\n    const _radius = innerRadius - space;\n    const _counterclockwise = point.y > y;\n    const side = _counterclockwise ? top + space : bottom - space;\n    const angles = getAngles(side, x, y, _radius);\n    const controllerMeta = {\n        _centerX: x,\n        _centerY: y,\n        _radius,\n        _counterclockwise,\n        ...angles\n    };\n    return {\n        controllerMeta,\n        point,\n        radius: Math.min(innerRadius, Math.min(square.right - square.left, square.bottom - square.top) / 2)\n    };\n}\nfunction getFitRatio({ width, height }, radius) {\n    const hypo = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n    return radius * 2 / hypo;\n}\nfunction getAngles(y, centerX, centerY, radius) {\n    const yk2 = Math.pow(centerY - y, 2);\n    const r2 = Math.pow(radius, 2);\n    const b = centerX * -2;\n    const c = Math.pow(centerX, 2) + yk2 - r2;\n    const delta = Math.pow(b, 2) - 4 * c;\n    if (delta <= 0) {\n        return {\n            _startAngle: 0,\n            _endAngle: chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.TAU\n        };\n    }\n    const start = (-b - Math.sqrt(delta)) / 2;\n    const end = (-b + Math.sqrt(delta)) / 2;\n    return {\n        _startAngle: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.getAngleFromPoint)({\n            x: centerX,\n            y: centerY\n        }, {\n            x: start,\n            y\n        }).angle,\n        _endAngle: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.getAngleFromPoint)({\n            x: centerX,\n            y: centerY\n        }, {\n            x: end,\n            y\n        }).angle\n    };\n}\nfunction drawBackground(ctx, element) {\n    const { _centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise, options } = element;\n    ctx.save();\n    const stroke = setBorderStyle(ctx, options);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.beginPath();\n    ctx.arc(_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise);\n    ctx.closePath();\n    ctx.fill();\n    if (stroke) {\n        ctx.stroke();\n    }\n    ctx.restore();\n}\nclass LabelAnnotation extends chart_js__WEBPACK_IMPORTED_MODULE_1__.Element {\n    inRange(mouseX, mouseY, axis, useFinalPosition) {\n        return inLabelRange({\n            x: mouseX,\n            y: mouseY\n        }, {\n            rect: this.getProps([\n                \"x\",\n                \"y\",\n                \"x2\",\n                \"y2\"\n            ], useFinalPosition),\n            center: this.getCenterPoint(useFinalPosition)\n        }, axis, {\n            rotation: this.rotation,\n            borderWidth: this.options.borderWidth,\n            hitTolerance: this.options.hitTolerance\n        });\n    }\n    getCenterPoint(useFinalPosition) {\n        return getElementCenterPoint(this, useFinalPosition);\n    }\n    draw(ctx) {\n        const options = this.options;\n        const visible = !(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(this._visible) || this._visible;\n        if (!options.display || !options.content || !visible) {\n            return;\n        }\n        ctx.save();\n        translate(ctx, this.getCenterPoint(), this.rotation);\n        drawCallout(ctx, this);\n        drawBox(ctx, this, options);\n        drawLabel(ctx, getLabelSize(this), options);\n        ctx.restore();\n    }\n    resolveElementProperties(chart, options) {\n        let point;\n        if (!isBoundToPoint(options)) {\n            const { centerX, centerY } = resolveBoxProperties(chart, options);\n            point = {\n                x: centerX,\n                y: centerY\n            };\n        } else {\n            point = getChartPoint(chart, options);\n        }\n        const padding = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)(options.padding);\n        const labelSize = measureLabelSize(chart.ctx, options);\n        const boxSize = measureLabelRectangle(point, labelSize, options, padding);\n        return {\n            initProperties: initAnimationProperties(chart, boxSize, options),\n            pointX: point.x,\n            pointY: point.y,\n            ...boxSize,\n            rotation: options.rotation\n        };\n    }\n}\nLabelAnnotation.id = \"labelAnnotation\";\nLabelAnnotation.defaults = {\n    adjustScaleRange: true,\n    backgroundColor: \"transparent\",\n    backgroundShadowColor: \"transparent\",\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderRadius: 0,\n    borderShadowColor: \"transparent\",\n    borderWidth: 0,\n    callout: {\n        borderCapStyle: \"butt\",\n        borderColor: undefined,\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: \"miter\",\n        borderWidth: 1,\n        display: false,\n        margin: 5,\n        position: \"auto\",\n        side: 5,\n        start: \"50%\"\n    },\n    color: \"black\",\n    content: null,\n    display: true,\n    font: {\n        family: undefined,\n        lineHeight: undefined,\n        size: undefined,\n        style: undefined,\n        weight: undefined\n    },\n    height: undefined,\n    hitTolerance: 0,\n    init: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: \"center\",\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: \"center\",\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    xMax: undefined,\n    xMin: undefined,\n    xScaleID: undefined,\n    xValue: undefined,\n    yAdjust: 0,\n    yMax: undefined,\n    yMin: undefined,\n    yScaleID: undefined,\n    yValue: undefined,\n    z: 0\n};\nLabelAnnotation.defaultRoutes = {\n    borderColor: \"color\"\n};\nfunction getLabelSize({ x, y, width, height, options }) {\n    const hBorderWidth = options.borderWidth / 2;\n    const padding = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)(options.padding);\n    return {\n        x: x + padding.left + hBorderWidth,\n        y: y + padding.top + hBorderWidth,\n        width: width - padding.left - padding.right - options.borderWidth,\n        height: height - padding.top - padding.bottom - options.borderWidth\n    };\n}\nconst pointInLine = (p1, p2, t)=>({\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    });\nconst interpolateX = (y, p1, p2)=>pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2)=>pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = (v)=>v * v;\nconst rangeLimit = (mouseX, mouseY, { x, y, x2, y2 }, axis)=>axis === \"y\" ? {\n        start: Math.min(y, y2),\n        end: Math.max(y, y2),\n        value: mouseY\n    } : {\n        start: Math.min(x, x2),\n        end: Math.max(x, x2),\n        value: mouseX\n    };\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\nconst coordInCurve = (start, cp, end, t)=>(1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\nconst pointInCurve = (start, cp, end, t)=>({\n        x: coordInCurve(start.x, cp.x, end.x, t),\n        y: coordInCurve(start.y, cp.y, end.y, t)\n    });\nconst coordAngleInCurve = (start, cp, end, t)=>2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\nconst angleInCurve = (start, cp, end, t)=>-Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI;\nclass LineAnnotation extends chart_js__WEBPACK_IMPORTED_MODULE_1__.Element {\n    inRange(mouseX, mouseY, axis, useFinalPosition) {\n        const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n        if (axis !== \"x\" && axis !== \"y\") {\n            const point = {\n                mouseX,\n                mouseY\n            };\n            const { path, ctx } = this;\n            if (path) {\n                setBorderStyle(ctx, this.options);\n                ctx.lineWidth += this.options.hitTolerance;\n                const { chart } = this.$context;\n                const mx = mouseX * chart.currentDevicePixelRatio;\n                const my = mouseY * chart.currentDevicePixelRatio;\n                const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\n                ctx.restore();\n                return result;\n            }\n            const epsilon = sqr(hitSize);\n            return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n        }\n        return inAxisRange(this, {\n            mouseX,\n            mouseY\n        }, axis, {\n            hitSize,\n            useFinalPosition\n        });\n    }\n    getCenterPoint(useFinalPosition) {\n        return getElementCenterPoint(this, useFinalPosition);\n    }\n    draw(ctx) {\n        const { x, y, x2, y2, cp, options } = this;\n        ctx.save();\n        if (!setBorderStyle(ctx, options)) {\n            // no border width, then line is not drawn\n            return ctx.restore();\n        }\n        setShadowStyle(ctx, options);\n        const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n        if (options.curve && cp) {\n            drawCurve(ctx, this, cp, length);\n            return ctx.restore();\n        }\n        const { startOpts, endOpts, startAdjust, endAdjust } = getArrowHeads(this);\n        const angle = Math.atan2(y2 - y, x2 - x);\n        ctx.translate(x, y);\n        ctx.rotate(angle);\n        ctx.beginPath();\n        ctx.moveTo(0 + startAdjust, 0);\n        ctx.lineTo(length - endAdjust, 0);\n        ctx.shadowColor = options.borderShadowColor;\n        ctx.stroke();\n        drawArrowHead(ctx, 0, startAdjust, startOpts);\n        drawArrowHead(ctx, length, -endAdjust, endOpts);\n        ctx.restore();\n    }\n    get label() {\n        return this.elements && this.elements[0];\n    }\n    resolveElementProperties(chart, options) {\n        const area = resolveLineProperties(chart, options);\n        const { x, y, x2, y2 } = area;\n        const inside = isLineInArea(area, chart.chartArea);\n        const properties = inside ? limitLineToArea({\n            x,\n            y\n        }, {\n            x: x2,\n            y: y2\n        }, chart.chartArea) : {\n            x,\n            y,\n            x2,\n            y2,\n            width: Math.abs(x2 - x),\n            height: Math.abs(y2 - y)\n        };\n        properties.centerX = (x2 + x) / 2;\n        properties.centerY = (y2 + y) / 2;\n        properties.initProperties = initAnimationProperties(chart, properties, options);\n        if (options.curve) {\n            const p1 = {\n                x: properties.x,\n                y: properties.y\n            };\n            const p2 = {\n                x: properties.x2,\n                y: properties.y2\n            };\n            properties.cp = getControlPoint(properties, options, (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.distanceBetweenPoints)(p1, p2));\n        }\n        const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n        // additonal prop to manage zoom/pan\n        labelProperties._visible = inside;\n        properties.elements = [\n            {\n                type: \"label\",\n                optionScope: \"label\",\n                properties: labelProperties,\n                initProperties: properties.initProperties\n            }\n        ];\n        return properties;\n    }\n}\nLineAnnotation.id = \"lineAnnotation\";\nconst arrowHeadsDefaults = {\n    backgroundColor: undefined,\n    backgroundShadowColor: undefined,\n    borderColor: undefined,\n    borderDash: undefined,\n    borderDashOffset: undefined,\n    borderShadowColor: undefined,\n    borderWidth: undefined,\n    display: undefined,\n    fill: undefined,\n    length: undefined,\n    shadowBlur: undefined,\n    shadowOffsetX: undefined,\n    shadowOffsetY: undefined,\n    width: undefined\n};\nLineAnnotation.defaults = {\n    adjustScaleRange: true,\n    arrowHeads: {\n        display: false,\n        end: Object.assign({}, arrowHeadsDefaults),\n        fill: false,\n        length: 12,\n        start: Object.assign({}, arrowHeadsDefaults),\n        width: 6\n    },\n    borderDash: [],\n    borderDashOffset: 0,\n    borderShadowColor: \"transparent\",\n    borderWidth: 2,\n    curve: false,\n    controlPoint: {\n        y: \"-50%\"\n    },\n    display: true,\n    endValue: undefined,\n    init: undefined,\n    hitTolerance: 0,\n    label: {\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        backgroundShadowColor: \"transparent\",\n        borderCapStyle: \"butt\",\n        borderColor: \"black\",\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: \"miter\",\n        borderRadius: 6,\n        borderShadowColor: \"transparent\",\n        borderWidth: 0,\n        callout: Object.assign({}, LabelAnnotation.defaults.callout),\n        color: \"#fff\",\n        content: null,\n        display: false,\n        drawTime: undefined,\n        font: {\n            family: undefined,\n            lineHeight: undefined,\n            size: undefined,\n            style: undefined,\n            weight: \"bold\"\n        },\n        height: undefined,\n        hitTolerance: undefined,\n        opacity: undefined,\n        padding: 6,\n        position: \"center\",\n        rotation: 0,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        textAlign: \"center\",\n        textStrokeColor: undefined,\n        textStrokeWidth: 0,\n        width: undefined,\n        xAdjust: 0,\n        yAdjust: 0,\n        z: undefined\n    },\n    scaleID: undefined,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    value: undefined,\n    xMax: undefined,\n    xMin: undefined,\n    xScaleID: undefined,\n    yMax: undefined,\n    yMin: undefined,\n    yScaleID: undefined,\n    z: 0\n};\nLineAnnotation.descriptors = {\n    arrowHeads: {\n        start: {\n            _fallback: true\n        },\n        end: {\n            _fallback: true\n        },\n        _fallback: true\n    }\n};\nLineAnnotation.defaultRoutes = {\n    borderColor: \"color\"\n};\nfunction inAxisRange(element, { mouseX, mouseY }, axis, { hitSize, useFinalPosition }) {\n    const limit = rangeLimit(mouseX, mouseY, element.getProps([\n        \"x\",\n        \"y\",\n        \"x2\",\n        \"y2\"\n    ], useFinalPosition), axis);\n    return inLimit(limit, hitSize) || isOnLabel(element, {\n        mouseX,\n        mouseY\n    }, useFinalPosition, axis);\n}\nfunction isLineInArea({ x, y, x2, y2 }, { top, right, bottom, left }) {\n    return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\nfunction limitPointToArea({ x, y }, p2, { top, right, bottom, left }) {\n    if (x < left) {\n        y = interpolateY(left, {\n            x,\n            y\n        }, p2);\n        x = left;\n    }\n    if (x > right) {\n        y = interpolateY(right, {\n            x,\n            y\n        }, p2);\n        x = right;\n    }\n    if (y < top) {\n        x = interpolateX(top, {\n            x,\n            y\n        }, p2);\n        y = top;\n    }\n    if (y > bottom) {\n        x = interpolateX(bottom, {\n            x,\n            y\n        }, p2);\n        y = bottom;\n    }\n    return {\n        x,\n        y\n    };\n}\nfunction limitLineToArea(p1, p2, area) {\n    const { x, y } = limitPointToArea(p1, p2, area);\n    const { x: x2, y: y2 } = limitPointToArea(p2, p1, area);\n    return {\n        x,\n        y,\n        x2,\n        y2,\n        width: Math.abs(x2 - x),\n        height: Math.abs(y2 - y)\n    };\n}\nfunction intersects(element, { mouseX, mouseY }, epsilon = EPSILON, useFinalPosition) {\n    // Adapted from https://stackoverflow.com/a/6853926/25507\n    const { x: x1, y: y1, x2, y2 } = element.getProps([\n        \"x\",\n        \"y\",\n        \"x2\",\n        \"y2\"\n    ], useFinalPosition);\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const lenSq = sqr(dx) + sqr(dy);\n    const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n    let xx, yy;\n    if (t < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (t > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + t * dx;\n        yy = y1 + t * dy;\n    }\n    return sqr(mouseX - xx) + sqr(mouseY - yy) <= epsilon;\n}\nfunction isOnLabel(element, { mouseX, mouseY }, useFinalPosition, axis) {\n    const label = element.label;\n    return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\nfunction resolveLabelElementProperties(chart, properties, options) {\n    const borderWidth = options.borderWidth;\n    const padding = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)(options.padding);\n    const textSize = measureLabelSize(chart.ctx, options);\n    const width = textSize.width + padding.width + borderWidth;\n    const height = textSize.height + padding.height + borderWidth;\n    return calculateLabelPosition(properties, options, {\n        width,\n        height,\n        padding\n    }, chart.chartArea);\n}\nfunction calculateAutoRotation(properties) {\n    const { x, y, x2, y2 } = properties;\n    const rotation = Math.atan2(y2 - y, x2 - x);\n    // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n    return rotation > chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI / 2 ? rotation - chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI : rotation < chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI / -2 ? rotation + chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI : rotation;\n}\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n    const { width, height, padding } = sizes;\n    const { xAdjust, yAdjust } = label;\n    const p1 = {\n        x: properties.x,\n        y: properties.y\n    };\n    const p2 = {\n        x: properties.x2,\n        y: properties.y2\n    };\n    const rotation = label.rotation === \"auto\" ? calculateAutoRotation(properties) : (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(label.rotation);\n    const size = rotatedSize(width, height, rotation);\n    const t = calculateT(properties, label, {\n        labelSize: size,\n        padding\n    }, chartArea);\n    const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\n    const xCoordinateSizes = {\n        size: size.w,\n        min: chartArea.left,\n        max: chartArea.right,\n        padding: padding.left\n    };\n    const yCoordinateSizes = {\n        size: size.h,\n        min: chartArea.top,\n        max: chartArea.bottom,\n        padding: padding.top\n    };\n    const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n    const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n    return {\n        x: centerX - width / 2,\n        y: centerY - height / 2,\n        x2: centerX + width / 2,\n        y2: centerY + height / 2,\n        centerX,\n        centerY,\n        pointX: pt.x,\n        pointY: pt.y,\n        width,\n        height,\n        rotation: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(rotation)\n    };\n}\nfunction rotatedSize(width, height, rotation) {\n    const cos = Math.cos(rotation);\n    const sin = Math.sin(rotation);\n    return {\n        w: Math.abs(width * cos) + Math.abs(height * sin),\n        h: Math.abs(width * sin) + Math.abs(height * cos)\n    };\n}\nfunction calculateT(properties, label, sizes, chartArea) {\n    let t;\n    const space = spaceAround(properties, chartArea);\n    if (label.position === \"start\") {\n        t = calculateTAdjust({\n            w: properties.x2 - properties.x,\n            h: properties.y2 - properties.y\n        }, sizes, label, space);\n    } else if (label.position === \"end\") {\n        t = 1 - calculateTAdjust({\n            w: properties.x - properties.x2,\n            h: properties.y - properties.y2\n        }, sizes, label, space);\n    } else {\n        t = getRelativePosition(1, label.position);\n    }\n    return t;\n}\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n    const { labelSize, padding } = sizes;\n    const lineW = lineSize.w * space.dx;\n    const lineH = lineSize.h * space.dy;\n    const x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;\n    const y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;\n    return clamp(Math.max(x, y), 0, 0.25);\n}\nfunction spaceAround(properties, chartArea) {\n    const { x, x2, y, y2 } = properties;\n    const t = Math.min(y, y2) - chartArea.top;\n    const l = Math.min(x, x2) - chartArea.left;\n    const b = chartArea.bottom - Math.max(y, y2);\n    const r = chartArea.right - Math.max(x, x2);\n    return {\n        x: Math.min(l, r),\n        y: Math.min(t, b),\n        dx: l <= r ? 1 : -1,\n        dy: t <= b ? 1 : -1\n    };\n}\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n    const { size, min, max, padding } = labelSizes;\n    const halfSize = size / 2;\n    if (size > max - min) {\n        // if it does not fit, display as much as possible\n        return (max + min) / 2;\n    }\n    if (min >= coordinate - padding - halfSize) {\n        coordinate = min + padding + halfSize;\n    }\n    if (max <= coordinate + padding + halfSize) {\n        coordinate = max - padding - halfSize;\n    }\n    return coordinate;\n}\nfunction getArrowHeads(line) {\n    const options = line.options;\n    const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n    const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n    return {\n        startOpts: arrowStartOpts,\n        endOpts: arrowEndOpts,\n        startAdjust: getLineAdjust(line, arrowStartOpts),\n        endAdjust: getLineAdjust(line, arrowEndOpts)\n    };\n}\nfunction getLineAdjust(line, arrowOpts) {\n    if (!arrowOpts || !arrowOpts.display) {\n        return 0;\n    }\n    const { length, width } = arrowOpts;\n    const adjust = line.options.borderWidth / 2;\n    const p1 = {\n        x: length,\n        y: width + adjust\n    };\n    const p2 = {\n        x: 0,\n        y: adjust\n    };\n    return Math.abs(interpolateX(0, p1, p2));\n}\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n    if (!arrowOpts || !arrowOpts.display) {\n        return;\n    }\n    const { length, width, fill, backgroundColor, borderColor } = arrowOpts;\n    const arrowOffsetX = Math.abs(offset - length) + adjust;\n    ctx.beginPath();\n    setShadowStyle(ctx, arrowOpts);\n    setBorderStyle(ctx, arrowOpts);\n    ctx.moveTo(arrowOffsetX, -width);\n    ctx.lineTo(offset + adjust, 0);\n    ctx.lineTo(arrowOffsetX, width);\n    if (fill === true) {\n        ctx.fillStyle = backgroundColor || borderColor;\n        ctx.closePath();\n        ctx.fill();\n        ctx.shadowColor = \"transparent\";\n    } else {\n        ctx.shadowColor = arrowOpts.borderShadowColor;\n    }\n    ctx.stroke();\n}\nfunction getControlPoint(properties, options, distance) {\n    const { x, y, x2, y2, centerX, centerY } = properties;\n    const angle = Math.atan2(y2 - y, x2 - x);\n    const cp = toPosition(options.controlPoint, 0);\n    const point = {\n        x: centerX + getSize(distance, cp.x, false),\n        y: centerY + getSize(distance, cp.y, false)\n    };\n    return rotated(point, {\n        x: centerX,\n        y: centerY\n    }, angle);\n}\nfunction drawArrowHeadOnCurve(ctx, { x, y }, { angle, adjust }, arrowOpts) {\n    if (!arrowOpts || !arrowOpts.display) {\n        return;\n    }\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    drawArrowHead(ctx, 0, -adjust, arrowOpts);\n    ctx.restore();\n}\nfunction drawCurve(ctx, element, cp, length) {\n    const { x, y, x2, y2, options } = element;\n    const { startOpts, endOpts, startAdjust, endAdjust } = getArrowHeads(element);\n    const p1 = {\n        x,\n        y\n    };\n    const p2 = {\n        x: x2,\n        y: y2\n    };\n    const startAngle = angleInCurve(p1, cp, p2, 0);\n    const endAngle = angleInCurve(p1, cp, p2, 1) - chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI;\n    const ps = pointInCurve(p1, cp, p2, startAdjust / length);\n    const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\n    const path = new Path2D();\n    ctx.beginPath();\n    path.moveTo(ps.x, ps.y);\n    path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke(path);\n    element.path = path;\n    element.ctx = ctx;\n    drawArrowHeadOnCurve(ctx, ps, {\n        angle: startAngle,\n        adjust: startAdjust\n    }, startOpts);\n    drawArrowHeadOnCurve(ctx, pe, {\n        angle: endAngle,\n        adjust: endAdjust\n    }, endOpts);\n}\nclass EllipseAnnotation extends chart_js__WEBPACK_IMPORTED_MODULE_1__.Element {\n    inRange(mouseX, mouseY, axis, useFinalPosition) {\n        const rotation = this.options.rotation;\n        const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n        if (axis !== \"x\" && axis !== \"y\") {\n            return pointInEllipse({\n                x: mouseX,\n                y: mouseY\n            }, this.getProps([\n                \"width\",\n                \"height\",\n                \"centerX\",\n                \"centerY\"\n            ], useFinalPosition), rotation, hitSize);\n        }\n        const { x, y, x2, y2 } = this.getProps([\n            \"x\",\n            \"y\",\n            \"x2\",\n            \"y2\"\n        ], useFinalPosition);\n        const limit = axis === \"y\" ? {\n            start: y,\n            end: y2\n        } : {\n            start: x,\n            end: x2\n        };\n        const rotatedPoint = rotated({\n            x: mouseX,\n            y: mouseY\n        }, this.getCenterPoint(useFinalPosition), (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(-rotation));\n        return rotatedPoint[axis] >= limit.start - hitSize - EPSILON && rotatedPoint[axis] <= limit.end + hitSize + EPSILON;\n    }\n    getCenterPoint(useFinalPosition) {\n        return getElementCenterPoint(this, useFinalPosition);\n    }\n    draw(ctx) {\n        const { width, height, centerX, centerY, options } = this;\n        ctx.save();\n        translate(ctx, this.getCenterPoint(), options.rotation);\n        setShadowStyle(ctx, this.options);\n        ctx.beginPath();\n        ctx.fillStyle = options.backgroundColor;\n        const stroke = setBorderStyle(ctx, options);\n        ctx.ellipse(centerX, centerY, height / 2, width / 2, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI / 2, 0, 2 * chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI);\n        ctx.fill();\n        if (stroke) {\n            ctx.shadowColor = options.borderShadowColor;\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    get label() {\n        return this.elements && this.elements[0];\n    }\n    resolveElementProperties(chart, options) {\n        return resolveBoxAndLabelProperties(chart, options);\n    }\n}\nEllipseAnnotation.id = \"ellipseAnnotation\";\nEllipseAnnotation.defaults = {\n    adjustScaleRange: true,\n    backgroundShadowColor: \"transparent\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderShadowColor: \"transparent\",\n    borderWidth: 1,\n    display: true,\n    hitTolerance: 0,\n    init: undefined,\n    label: Object.assign({}, BoxAnnotation.defaults.label),\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    xMax: undefined,\n    xMin: undefined,\n    xScaleID: undefined,\n    yMax: undefined,\n    yMin: undefined,\n    yScaleID: undefined,\n    z: 0\n};\nEllipseAnnotation.defaultRoutes = {\n    borderColor: \"color\",\n    backgroundColor: \"color\"\n};\nEllipseAnnotation.descriptors = {\n    label: {\n        _fallback: true\n    }\n};\nfunction pointInEllipse(p, ellipse, rotation, hitSize) {\n    const { width, height, centerX, centerY } = ellipse;\n    const xRadius = width / 2;\n    const yRadius = height / 2;\n    if (xRadius <= 0 || yRadius <= 0) {\n        return false;\n    }\n    // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n    const angle = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(rotation || 0);\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n    const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n    return a / Math.pow(xRadius + hitSize, 2) + b / Math.pow(yRadius + hitSize, 2) <= 1.0001;\n}\nclass PointAnnotation extends chart_js__WEBPACK_IMPORTED_MODULE_1__.Element {\n    inRange(mouseX, mouseY, axis, useFinalPosition) {\n        const { x, y, x2, y2, width } = this.getProps([\n            \"x\",\n            \"y\",\n            \"x2\",\n            \"y2\",\n            \"width\"\n        ], useFinalPosition);\n        const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n        if (axis !== \"x\" && axis !== \"y\") {\n            return inPointRange({\n                x: mouseX,\n                y: mouseY\n            }, this.getCenterPoint(useFinalPosition), width / 2, hitSize);\n        }\n        const limit = axis === \"y\" ? {\n            start: y,\n            end: y2,\n            value: mouseY\n        } : {\n            start: x,\n            end: x2,\n            value: mouseX\n        };\n        return inLimit(limit, hitSize);\n    }\n    getCenterPoint(useFinalPosition) {\n        return getElementCenterPoint(this, useFinalPosition);\n    }\n    draw(ctx) {\n        const options = this.options;\n        const borderWidth = options.borderWidth;\n        if (options.radius < 0.1) {\n            return;\n        }\n        ctx.save();\n        ctx.fillStyle = options.backgroundColor;\n        setShadowStyle(ctx, options);\n        const stroke = setBorderStyle(ctx, options);\n        drawPoint(ctx, this, this.centerX, this.centerY);\n        if (stroke && !isImageOrCanvas(options.pointStyle)) {\n            ctx.shadowColor = options.borderShadowColor;\n            ctx.stroke();\n        }\n        ctx.restore();\n        options.borderWidth = borderWidth;\n    }\n    resolveElementProperties(chart, options) {\n        const properties = resolvePointProperties(chart, options);\n        properties.initProperties = initAnimationProperties(chart, properties, options);\n        return properties;\n    }\n}\nPointAnnotation.id = \"pointAnnotation\";\nPointAnnotation.defaults = {\n    adjustScaleRange: true,\n    backgroundShadowColor: \"transparent\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderShadowColor: \"transparent\",\n    borderWidth: 1,\n    display: true,\n    hitTolerance: 0,\n    init: undefined,\n    pointStyle: \"circle\",\n    radius: 10,\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    xAdjust: 0,\n    xMax: undefined,\n    xMin: undefined,\n    xScaleID: undefined,\n    xValue: undefined,\n    yAdjust: 0,\n    yMax: undefined,\n    yMin: undefined,\n    yScaleID: undefined,\n    yValue: undefined,\n    z: 0\n};\nPointAnnotation.defaultRoutes = {\n    borderColor: \"color\",\n    backgroundColor: \"color\"\n};\nclass PolygonAnnotation extends chart_js__WEBPACK_IMPORTED_MODULE_1__.Element {\n    inRange(mouseX, mouseY, axis, useFinalPosition) {\n        if (axis !== \"x\" && axis !== \"y\") {\n            return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n        }\n        const rotatedPoint = rotated({\n            x: mouseX,\n            y: mouseY\n        }, this.getCenterPoint(useFinalPosition), (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toRadians)(-this.options.rotation));\n        const axisPoints = this.elements.map((point)=>axis === \"y\" ? point.bY : point.bX);\n        const start = Math.min(...axisPoints);\n        const end = Math.max(...axisPoints);\n        return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n    }\n    getCenterPoint(useFinalPosition) {\n        return getElementCenterPoint(this, useFinalPosition);\n    }\n    draw(ctx) {\n        const { elements, options } = this;\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = options.backgroundColor;\n        setShadowStyle(ctx, options);\n        const stroke = setBorderStyle(ctx, options);\n        let first = true;\n        for (const el of elements){\n            if (first) {\n                ctx.moveTo(el.x, el.y);\n                first = false;\n            } else {\n                ctx.lineTo(el.x, el.y);\n            }\n        }\n        ctx.closePath();\n        ctx.fill();\n        // If no border, don't draw it\n        if (stroke) {\n            ctx.shadowColor = options.borderShadowColor;\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    resolveElementProperties(chart, options) {\n        const properties = resolvePointProperties(chart, options);\n        const { sides, rotation } = options;\n        const elements = [];\n        const angle = 2 * chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.PI / sides;\n        let rad = rotation * chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.RAD_PER_DEG;\n        for(let i = 0; i < sides; i++, rad += angle){\n            const elProps = buildPointElement(properties, options, rad);\n            elProps.initProperties = initAnimationProperties(chart, properties, options);\n            elements.push(elProps);\n        }\n        properties.elements = elements;\n        return properties;\n    }\n}\nPolygonAnnotation.id = \"polygonAnnotation\";\nPolygonAnnotation.defaults = {\n    adjustScaleRange: true,\n    backgroundShadowColor: \"transparent\",\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderShadowColor: \"transparent\",\n    borderWidth: 1,\n    display: true,\n    hitTolerance: 0,\n    init: undefined,\n    point: {\n        radius: 0\n    },\n    radius: 10,\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    sides: 3,\n    xAdjust: 0,\n    xMax: undefined,\n    xMin: undefined,\n    xScaleID: undefined,\n    xValue: undefined,\n    yAdjust: 0,\n    yMax: undefined,\n    yMin: undefined,\n    yScaleID: undefined,\n    yValue: undefined,\n    z: 0\n};\nPolygonAnnotation.defaultRoutes = {\n    borderColor: \"color\",\n    backgroundColor: \"color\"\n};\nfunction buildPointElement({ centerX, centerY }, { radius, borderWidth, hitTolerance }, rad) {\n    const hitSize = (borderWidth + hitTolerance) / 2;\n    const sin = Math.sin(rad);\n    const cos = Math.cos(rad);\n    const point = {\n        x: centerX + sin * radius,\n        y: centerY - cos * radius\n    };\n    return {\n        type: \"point\",\n        optionScope: \"point\",\n        properties: {\n            x: point.x,\n            y: point.y,\n            centerX: point.x,\n            centerY: point.y,\n            bX: centerX + sin * (radius + hitSize),\n            bY: centerY - cos * (radius + hitSize)\n        }\n    };\n}\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n    let isInside = false;\n    let A = points[points.length - 1].getProps([\n        \"bX\",\n        \"bY\"\n    ], useFinalPosition);\n    for (const point of points){\n        const B = point.getProps([\n            \"bX\",\n            \"bY\"\n        ], useFinalPosition);\n        if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n            isInside = !isInside;\n        }\n        A = B;\n    }\n    return isInside;\n}\nconst annotationTypes = {\n    box: BoxAnnotation,\n    doughnutLabel: DoughnutLabelAnnotation,\n    ellipse: EllipseAnnotation,\n    label: LabelAnnotation,\n    line: LineAnnotation,\n    point: PointAnnotation,\n    polygon: PolygonAnnotation\n};\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */ Object.keys(annotationTypes).forEach((key)=>{\n    chart_js__WEBPACK_IMPORTED_MODULE_2__.d.describe(`elements.${annotationTypes[key].id}`, {\n        _fallback: \"plugins.annotation.common\"\n    });\n});\nconst directUpdater = {\n    update: Object.assign\n};\nconst hooks$1 = eventHooks.concat(elementHooks);\nconst resolve = (value, optDefs)=>(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(optDefs) ? resolveObj(value, optDefs) : value;\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */ /**\n * @param {string} prop\n * @returns {boolean}\n */ const isIndexable = (prop)=>prop === \"color\" || prop === \"font\";\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */ function resolveType(type = \"line\") {\n    if (annotationTypes[type]) {\n        return type;\n    }\n    console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n    return \"line\";\n}\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n * @param {UpdateMode} mode\n */ function updateElements(chart, state, options, mode) {\n    const animations = resolveAnimations(chart, options.animations, mode);\n    const annotations = state.annotations;\n    const elements = resyncElements(state.elements, annotations);\n    for(let i = 0; i < annotations.length; i++){\n        const annotationOptions = annotations[i];\n        const element = getOrCreateElement(elements, i, annotationOptions.type);\n        const resolver = annotationOptions.setContext(getContext(chart, element, elements, annotationOptions));\n        const properties = element.resolveElementProperties(chart, resolver);\n        properties.skip = toSkip(properties);\n        if (\"elements\" in properties) {\n            updateSubElements(element, properties.elements, resolver, animations);\n            // Remove the sub-element definitions from properties, so the actual elements\n            // are not overwritten by their definitions\n            delete properties.elements;\n        }\n        if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.defined)(element.x)) {\n            // If the element is newly created, assing the properties directly - to\n            // make them readily awailable to any scriptable options. If we do not do this,\n            // the properties retruned by `resolveElementProperties` are available only\n            // after options resolution.\n            Object.assign(element, properties);\n        }\n        Object.assign(element, properties.initProperties);\n        properties.options = resolveAnnotationOptions(resolver);\n        animations.update(element, properties);\n    }\n}\nfunction toSkip(properties) {\n    return isNaN(properties.x) || isNaN(properties.y);\n}\nfunction resolveAnimations(chart, animOpts, mode) {\n    if (mode === \"reset\" || mode === \"none\" || mode === \"resize\") {\n        return directUpdater;\n    }\n    return new chart_js__WEBPACK_IMPORTED_MODULE_1__.Animations(chart, animOpts);\n}\nfunction updateSubElements(mainElement, elements, resolver, animations) {\n    const subElements = mainElement.elements || (mainElement.elements = []);\n    subElements.length = elements.length;\n    for(let i = 0; i < elements.length; i++){\n        const definition = elements[i];\n        const properties = definition.properties;\n        const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\n        const subResolver = resolver[definition.optionScope].override(definition);\n        properties.options = resolveAnnotationOptions(subResolver);\n        animations.update(subElement, properties);\n    }\n}\nfunction getOrCreateElement(elements, index, type, initProperties) {\n    const elementClass = annotationTypes[resolveType(type)];\n    let element = elements[index];\n    if (!element || !(element instanceof elementClass)) {\n        element = elements[index] = new elementClass();\n        Object.assign(element, initProperties);\n    }\n    return element;\n}\nfunction resolveAnnotationOptions(resolver) {\n    const elementClass = annotationTypes[resolveType(resolver.type)];\n    const result = {};\n    result.id = resolver.id;\n    result.type = resolver.type;\n    result.drawTime = resolver.drawTime;\n    Object.assign(result, resolveObj(resolver, elementClass.defaults), resolveObj(resolver, elementClass.defaultRoutes));\n    for (const hook of hooks$1){\n        result[hook] = resolver[hook];\n    }\n    return result;\n}\nfunction resolveObj(resolver, defs) {\n    const result = {};\n    for (const prop of Object.keys(defs)){\n        const optDefs = defs[prop];\n        const value = resolver[prop];\n        if (isIndexable(prop) && (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {\n            result[prop] = value.map((item)=>resolve(item, optDefs));\n        } else {\n            result[prop] = resolve(value, optDefs);\n        }\n    }\n    return result;\n}\nfunction getContext(chart, element, elements, annotation) {\n    return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n        element,\n        get elements () {\n            return elements.filter((el)=>el && el.options);\n        },\n        id: annotation.id,\n        type: \"annotation\"\n    }));\n}\nfunction resyncElements(elements, annotations) {\n    const count = annotations.length;\n    const start = elements.length;\n    if (start < count) {\n        const add = count - start;\n        elements.splice(start, 0, ...new Array(add));\n    } else if (start > count) {\n        elements.splice(count, start - count);\n    }\n    return elements;\n}\nvar version = \"3.1.0\";\nconst chartStates = new Map();\nconst isNotDoughnutLabel = (annotation)=>annotation.type !== \"doughnutLabel\";\nconst hooks = eventHooks.concat(elementHooks);\nvar annotation = {\n    id: \"annotation\",\n    version,\n    beforeRegister () {\n        requireVersion(\"chart.js\", \"4.0\", chart_js__WEBPACK_IMPORTED_MODULE_1__.Chart.version);\n    },\n    afterRegister () {\n        chart_js__WEBPACK_IMPORTED_MODULE_1__.Chart.register(annotationTypes);\n    },\n    afterUnregister () {\n        chart_js__WEBPACK_IMPORTED_MODULE_1__.Chart.unregister(annotationTypes);\n    },\n    beforeInit (chart) {\n        chartStates.set(chart, {\n            annotations: [],\n            elements: [],\n            visibleElements: [],\n            listeners: {},\n            listened: false,\n            moveListened: false,\n            hooks: {},\n            hooked: false,\n            hovered: []\n        });\n    },\n    beforeUpdate (chart, args, options) {\n        const state = chartStates.get(chart);\n        const annotations = state.annotations = [];\n        let annotationOptions = options.annotations;\n        if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(annotationOptions)) {\n            Object.keys(annotationOptions).forEach((key)=>{\n                const value = annotationOptions[key];\n                if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {\n                    value.id = key;\n                    annotations.push(value);\n                }\n            });\n        } else if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(annotationOptions)) {\n            annotations.push(...annotationOptions);\n        }\n        verifyScaleOptions(annotations.filter(isNotDoughnutLabel), chart.scales);\n    },\n    afterDataLimits (chart, args) {\n        const state = chartStates.get(chart);\n        adjustScaleRange(chart, args.scale, state.annotations.filter(isNotDoughnutLabel).filter((a)=>a.display && a.adjustScaleRange));\n    },\n    afterUpdate (chart, args, options) {\n        const state = chartStates.get(chart);\n        updateListeners(chart, state, options);\n        updateElements(chart, state, options, args.mode);\n        state.visibleElements = state.elements.filter((el)=>!el.skip && el.options.display);\n        updateHooks(chart, state, options);\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        draw(chart, \"beforeDatasetsDraw\", options.clip);\n    },\n    afterDatasetsDraw (chart, _args, options) {\n        draw(chart, \"afterDatasetsDraw\", options.clip);\n    },\n    beforeDatasetDraw (chart, _args, options) {\n        draw(chart, _args.index, options.clip);\n    },\n    beforeDraw (chart, _args, options) {\n        draw(chart, \"beforeDraw\", options.clip);\n    },\n    afterDraw (chart, _args, options) {\n        draw(chart, \"afterDraw\", options.clip);\n    },\n    beforeEvent (chart, args, options) {\n        const state = chartStates.get(chart);\n        if (handleEvent(state, args.event, options)) {\n            args.changed = true;\n        }\n    },\n    afterDestroy (chart) {\n        chartStates.delete(chart);\n    },\n    getAnnotations (chart) {\n        const state = chartStates.get(chart);\n        return state ? state.elements : [];\n    },\n    // only for testing\n    _getAnnotationElementsAtEventForMode (visibleElements, event, options) {\n        return getElements(visibleElements, event, options);\n    },\n    defaults: {\n        animations: {\n            numbers: {\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"x2\",\n                    \"y2\",\n                    \"width\",\n                    \"height\",\n                    \"centerX\",\n                    \"centerY\",\n                    \"pointX\",\n                    \"pointY\",\n                    \"radius\"\n                ],\n                type: \"number\"\n            },\n            colors: {\n                properties: [\n                    \"backgroundColor\",\n                    \"borderColor\"\n                ],\n                type: \"color\"\n            }\n        },\n        clip: true,\n        interaction: {\n            mode: undefined,\n            axis: undefined,\n            intersect: undefined\n        },\n        common: {\n            drawTime: \"afterDatasetsDraw\",\n            init: false,\n            label: {}\n        }\n    },\n    descriptors: {\n        _indexable: false,\n        _scriptable: (prop)=>!hooks.includes(prop) && prop !== \"init\",\n        annotations: {\n            _allKeys: false,\n            _fallback: (prop, opts)=>`elements.${annotationTypes[resolveType(opts.type)].id}`\n        },\n        interaction: {\n            _fallback: true\n        },\n        common: {\n            label: {\n                _indexable: isIndexable,\n                _fallback: true\n            },\n            _indexable: isIndexable\n        }\n    },\n    additionalOptionScopes: [\n        \"\"\n    ]\n};\nfunction draw(chart, caller, clip) {\n    const { ctx, chartArea } = chart;\n    const state = chartStates.get(chart);\n    if (clip) {\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.clipArea)(ctx, chartArea);\n    }\n    const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b)=>a.element.options.z - b.element.options.z);\n    for (const item of drawableElements){\n        drawElement(ctx, chartArea, state, item);\n    }\n    if (clip) {\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.unclipArea)(ctx);\n    }\n}\nfunction getDrawableElements(elements, caller) {\n    const drawableElements = [];\n    for (const el of elements){\n        if (el.options.drawTime === caller) {\n            drawableElements.push({\n                element: el,\n                main: true\n            });\n        }\n        if (el.elements && el.elements.length) {\n            for (const sub of el.elements){\n                if (sub.options.display && sub.options.drawTime === caller) {\n                    drawableElements.push({\n                        element: sub\n                    });\n                }\n            }\n        }\n    }\n    return drawableElements;\n}\nfunction drawElement(ctx, chartArea, state, item) {\n    const el = item.element;\n    if (item.main) {\n        invokeHook(state, el, \"beforeDraw\");\n        el.draw(ctx, chartArea);\n        invokeHook(state, el, \"afterDraw\");\n    } else {\n        el.draw(ctx, chartArea);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tYW5ub3RhdGlvbi9kaXN0L2NoYXJ0anMtcGx1Z2luLWFubm90YXRpb24uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNtRjtBQUMwTztBQUU5VDs7O0NBR0MsR0FFRCxNQUFNNkIsY0FBYztJQUNsQkMsT0FBTztRQUNMOzs7OztLQUtDLEdBQ0RDLE9BQU1DLGVBQWUsRUFBRUMsS0FBSztZQUMxQixPQUFPQyxlQUFlRixpQkFBaUJDLE9BQU87Z0JBQUNFLFdBQVc7WUFBSTtRQUNoRTtRQUVBOzs7Ozs7S0FNQyxHQUNEQyxTQUFRSixlQUFlLEVBQUVDLEtBQUssRUFBRUksT0FBTztZQUNyQyxPQUFPQyxlQUFlTixpQkFBaUJDLE9BQU9JO1FBQ2hEO1FBQ0E7Ozs7OztLQU1DLEdBQ0RFLEdBQUVQLGVBQWUsRUFBRUMsS0FBSyxFQUFFSSxPQUFPO1lBQy9CLE9BQU9ILGVBQWVGLGlCQUFpQkMsT0FBTztnQkFBQ0UsV0FBV0UsUUFBUUYsU0FBUztnQkFBRUssTUFBTTtZQUFHO1FBQ3hGO1FBRUE7Ozs7OztLQU1DLEdBQ0RDLEdBQUVULGVBQWUsRUFBRUMsS0FBSyxFQUFFSSxPQUFPO1lBQy9CLE9BQU9ILGVBQWVGLGlCQUFpQkMsT0FBTztnQkFBQ0UsV0FBV0UsUUFBUUYsU0FBUztnQkFBRUssTUFBTTtZQUFHO1FBQ3hGO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNFLFlBQVlWLGVBQWUsRUFBRUMsS0FBSyxFQUFFSSxPQUFPO0lBQ2xELE1BQU1NLE9BQU9kLFlBQVlDLEtBQUssQ0FBQ08sUUFBUU0sSUFBSSxDQUFDLElBQUlkLFlBQVlDLEtBQUssQ0FBQ00sT0FBTztJQUN6RSxPQUFPTyxLQUFLWCxpQkFBaUJDLE9BQU9JO0FBQ3RDO0FBRUEsU0FBU08sY0FBY0MsT0FBTyxFQUFFWixLQUFLLEVBQUVPLElBQUk7SUFDekMsSUFBSUEsU0FBUyxPQUFPQSxT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QUFvQnhTLFFBQVEsRUFBRXNTLE1BQU07SUFDM0MsTUFBTUMsbUJBQW1CLEVBQUU7SUFDM0IsS0FBSyxNQUFNN0UsTUFBTTFOLFNBQVU7UUFDekIsSUFBSTBOLEdBQUcvZ0IsT0FBTyxDQUFDNlgsUUFBUSxLQUFLOE4sUUFBUTtZQUNsQ0MsaUJBQWlCdmtCLElBQUksQ0FBQztnQkFBQ2IsU0FBU3VnQjtnQkFBSWdGLE1BQU07WUFBSTtRQUNoRDtRQUNBLElBQUloRixHQUFHMU4sUUFBUSxJQUFJME4sR0FBRzFOLFFBQVEsQ0FBQ2hSLE1BQU0sRUFBRTtZQUNyQyxLQUFLLE1BQU0yakIsT0FBT2pGLEdBQUcxTixRQUFRLENBQUU7Z0JBQzdCLElBQUkyUyxJQUFJaG1CLE9BQU8sQ0FBQ3FQLE9BQU8sSUFBSTJXLElBQUlobUIsT0FBTyxDQUFDNlgsUUFBUSxLQUFLOE4sUUFBUTtvQkFDMURDLGlCQUFpQnZrQixJQUFJLENBQUM7d0JBQUNiLFNBQVN3bEI7b0JBQUc7Z0JBQ3JDO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT0o7QUFDVDtBQUVBLFNBQVNFLFlBQVloYyxHQUFHLEVBQUU4SCxTQUFTLEVBQUU2QyxLQUFLLEVBQUVqTCxJQUFJO0lBQzlDLE1BQU11WCxLQUFLdlgsS0FBS2hKLE9BQU87SUFDdkIsSUFBSWdKLEtBQUt1YyxJQUFJLEVBQUU7UUFDYi9QLFdBQVd2QixPQUFPc00sSUFBSTtRQUN0QkEsR0FBR3JKLElBQUksQ0FBQzVOLEtBQUs4SDtRQUNib0UsV0FBV3ZCLE9BQU9zTSxJQUFJO0lBQ3hCLE9BQU87UUFDTEEsR0FBR3JKLElBQUksQ0FBQzVOLEtBQUs4SDtJQUNmO0FBQ0Y7QUFFaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXN0aW4tbXVsdGlmYW1pbHktcmVwb3J0Ly4vbm9kZV9tb2R1bGVzL2NoYXJ0anMtcGx1Z2luLWFubm90YXRpb24vZGlzdC9jaGFydGpzLXBsdWdpbi1hbm5vdGF0aW9uLmVzbS5qcz9lYjc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBjaGFydGpzLXBsdWdpbi1hbm5vdGF0aW9uIHYzLjEuMFxuKiBodHRwczovL3d3dy5jaGFydGpzLm9yZy9jaGFydGpzLXBsdWdpbi1hbm5vdGF0aW9uL2luZGV4XG4gKiAoYykgMjAyNCBjaGFydGpzLXBsdWdpbi1hbm5vdGF0aW9uIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IEVsZW1lbnQsIERvdWdobnV0Q29udHJvbGxlciwgZGVmYXVsdHMsIEFuaW1hdGlvbnMsIENoYXJ0IH0gZnJvbSAnY2hhcnQuanMnO1xuaW1wb3J0IHsgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCB0b1JhZGlhbnMsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdCwgZGVmaW5lZCwgaXNGdW5jdGlvbiwgY2FsbGJhY2ssIGlzQXJyYXksIHRvRm9udCwgYWRkUm91bmRlZFJlY3RQYXRoLCB0b1RSQkxDb3JuZXJzLCBRVUFSVEVSX1BJLCBQSSwgSEFMRl9QSSwgVFdPX1RISVJEU19QSSwgVEFVLCBpc051bWJlciwgUkFEX1BFUl9ERUcsIHRvUGFkZGluZywgaXNGaW5pdGUsIGdldEFuZ2xlRnJvbVBvaW50LCB0b0RlZ3JlZXMsIGNsaXBBcmVhLCB1bmNsaXBBcmVhIH0gZnJvbSAnY2hhcnQuanMvaGVscGVycyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoXCJjaGFydC5qc1wiKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2VsZW1lbnQnKS5Bbm5vdGF0aW9uRWxlbWVudCB9IEFubm90YXRpb25FbGVtZW50XG4gKi9cblxuY29uc3QgaW50ZXJhY3Rpb24gPSB7XG4gIG1vZGVzOiB7XG4gICAgLyoqXG4gICAgICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7QW5ub3RhdGlvbkVsZW1lbnRbXX0gdmlzaWJsZUVsZW1lbnRzIC0gYW5ub3RhdGlvbiBlbGVtZW50cyB3aGljaCBhcmUgdmlzaWJsZVxuICAgICAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG4gICAgICogQHJldHVybiB7QW5ub3RhdGlvbkVsZW1lbnRbXX0gLSBlbGVtZW50cyB0aGF0IGFyZSBmb3VuZFxuICAgICAqL1xuICAgIHBvaW50KHZpc2libGVFbGVtZW50cywgZXZlbnQpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJFbGVtZW50cyh2aXNpYmxlRWxlbWVudHMsIGV2ZW50LCB7aW50ZXJzZWN0OiB0cnVlfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtBbm5vdGF0aW9uRWxlbWVudFtdfSB2aXNpYmxlRWxlbWVudHMgLSBhbm5vdGF0aW9uIGVsZW1lbnRzIHdoaWNoIGFyZSB2aXNpYmxlXG4gICAgICogQHBhcmFtIHtDaGFydEV2ZW50fSBldmVudCAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGludGVyYWN0aW9uIG9wdGlvbnMgdG8gdXNlXG4gICAgICogQHJldHVybiB7QW5ub3RhdGlvbkVsZW1lbnRbXX0gLSBlbGVtZW50cyB0aGF0IGFyZSBmb3VuZCAob25seSAxIGVsZW1lbnQpXG4gICAgICovXG4gICAgbmVhcmVzdCh2aXNpYmxlRWxlbWVudHMsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW0odmlzaWJsZUVsZW1lbnRzLCBldmVudCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge0Fubm90YXRpb25FbGVtZW50W119IHZpc2libGVFbGVtZW50cyAtIGFubm90YXRpb24gZWxlbWVudHMgd2hpY2ggYXJlIHZpc2libGVcbiAgICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gaW50ZXJhY3Rpb24gb3B0aW9ucyB0byB1c2VcbiAgICAgKiBAcmV0dXJuIHtBbm5vdGF0aW9uRWxlbWVudFtdfSAtIGVsZW1lbnRzIHRoYXQgYXJlIGZvdW5kXG4gICAgICovXG4gICAgeCh2aXNpYmxlRWxlbWVudHMsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZmlsdGVyRWxlbWVudHModmlzaWJsZUVsZW1lbnRzLCBldmVudCwge2ludGVyc2VjdDogb3B0aW9ucy5pbnRlcnNlY3QsIGF4aXM6ICd4J30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB5IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge0Fubm90YXRpb25FbGVtZW50W119IHZpc2libGVFbGVtZW50cyAtIGFubm90YXRpb24gZWxlbWVudHMgd2hpY2ggYXJlIHZpc2libGVcbiAgICAgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gaW50ZXJhY3Rpb24gb3B0aW9ucyB0byB1c2VcbiAgICAgKiBAcmV0dXJuIHtBbm5vdGF0aW9uRWxlbWVudFtdfSAtIGVsZW1lbnRzIHRoYXQgYXJlIGZvdW5kXG4gICAgICovXG4gICAgeSh2aXNpYmxlRWxlbWVudHMsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZmlsdGVyRWxlbWVudHModmlzaWJsZUVsZW1lbnRzLCBldmVudCwge2ludGVyc2VjdDogb3B0aW9ucy5pbnRlcnNlY3QsIGF4aXM6ICd5J30pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtBbm5vdGF0aW9uRWxlbWVudFtdfSB2aXNpYmxlRWxlbWVudHMgLSBhbm5vdGF0aW9uIGVsZW1lbnRzIHdoaWNoIGFyZSB2aXNpYmxlXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBpbnRlcmFjdGlvbiBvcHRpb25zIHRvIHVzZVxuICogQHJldHVybiB7QW5ub3RhdGlvbkVsZW1lbnRbXX0gLSBlbGVtZW50cyB0aGF0IGFyZSBmb3VuZFxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50cyh2aXNpYmxlRWxlbWVudHMsIGV2ZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IG1vZGUgPSBpbnRlcmFjdGlvbi5tb2Rlc1tvcHRpb25zLm1vZGVdIHx8IGludGVyYWN0aW9uLm1vZGVzLm5lYXJlc3Q7XG4gIHJldHVybiBtb2RlKHZpc2libGVFbGVtZW50cywgZXZlbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBpblJhbmdlQnlBeGlzKGVsZW1lbnQsIGV2ZW50LCBheGlzKSB7XG4gIGlmIChheGlzICE9PSAneCcgJiYgYXhpcyAhPT0gJ3knKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuaW5SYW5nZShldmVudC54LCBldmVudC55LCAneCcsIHRydWUpIHx8IGVsZW1lbnQuaW5SYW5nZShldmVudC54LCBldmVudC55LCAneScsIHRydWUpO1xuICB9XG4gIHJldHVybiBlbGVtZW50LmluUmFuZ2UoZXZlbnQueCwgZXZlbnQueSwgYXhpcywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBvaW50QnlBeGlzKGV2ZW50LCBjZW50ZXIsIGF4aXMpIHtcbiAgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgIHJldHVybiB7eDogZXZlbnQueCwgeTogY2VudGVyLnl9O1xuICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgIHJldHVybiB7eDogY2VudGVyLngsIHk6IGV2ZW50Lnl9O1xuICB9XG4gIHJldHVybiBjZW50ZXI7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckVsZW1lbnRzKHZpc2libGVFbGVtZW50cywgZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHZpc2libGVFbGVtZW50cy5maWx0ZXIoKGVsZW1lbnQpID0+IG9wdGlvbnMuaW50ZXJzZWN0ID8gZWxlbWVudC5pblJhbmdlKGV2ZW50LngsIGV2ZW50LnkpIDogaW5SYW5nZUJ5QXhpcyhlbGVtZW50LCBldmVudCwgb3B0aW9ucy5heGlzKSk7XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtKHZpc2libGVFbGVtZW50cywgZXZlbnQsIG9wdGlvbnMpIHtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIHJldHVybiBmaWx0ZXJFbGVtZW50cyh2aXNpYmxlRWxlbWVudHMsIGV2ZW50LCBvcHRpb25zKVxuICAgIC5yZWR1Y2UoKG5lYXJlc3RJdGVtcywgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgY29uc3QgZXZlblBvaW50ID0gZ2V0UG9pbnRCeUF4aXMoZXZlbnQsIGNlbnRlciwgb3B0aW9ucy5heGlzKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50LCBldmVuUG9pbnQpO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbmVhcmVzdEl0ZW1zID0gW2VsZW1lbnRdO1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgICAgLy8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcbiAgICAgICAgbmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZWFyZXN0SXRlbXM7XG4gICAgfSwgW10pXG4gICAgLnNvcnQoKGEsIGIpID0+IGEuX2luZGV4IC0gYi5faW5kZXgpXG4gICAgLnNsaWNlKDAsIDEpOyAvLyByZXR1cm4gb25seSB0aGUgdG9wIGl0ZW07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnY2hhcnQuanMnKS5Qb2ludH0gUG9pbnRcbiAqL1xuXG4vKipcbiAqIFJvdGF0ZSBhIGBwb2ludGAgcmVsYXRpdmUgdG8gYGNlbnRlcmAgcG9pbnQgYnkgYGFuZ2xlYFxuICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBjZW50ZXIgLSBjZW50ZXIgcG9pbnQgZm9yIHJvdGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBhbmdsZSBmb3Igcm90YXRpb24sIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtQb2ludH0gcm90YXRlZCBwb2ludFxuICovXG5mdW5jdGlvbiByb3RhdGVkKHBvaW50LCBjZW50ZXIsIGFuZ2xlKSB7XG4gIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICBjb25zdCBjeCA9IGNlbnRlci54O1xuICBjb25zdCBjeSA9IGNlbnRlci55O1xuXG4gIHJldHVybiB7XG4gICAgeDogY3ggKyBjb3MgKiAocG9pbnQueCAtIGN4KSAtIHNpbiAqIChwb2ludC55IC0gY3kpLFxuICAgIHk6IGN5ICsgc2luICogKHBvaW50LnggLSBjeCkgKyBjb3MgKiAocG9pbnQueSAtIGN5KVxuICB9O1xufVxuXG5jb25zdCBpc09sZGVyUGFydCA9IChhY3QsIHJlcSkgPT4gcmVxID4gYWN0IHx8IChhY3QubGVuZ3RoID4gcmVxLmxlbmd0aCAmJiBhY3Quc2xpY2UoMCwgcmVxLmxlbmd0aCkgPT09IHJlcSk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2NoYXJ0LmpzJykuUG9pbnQgfSBQb2ludFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2NoYXJ0LmpzJykuSW50ZXJhY3Rpb25BeGlzIH0gSW50ZXJhY3Rpb25BeGlzXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvZWxlbWVudCcpLkFubm90YXRpb25FbGVtZW50IH0gQW5ub3RhdGlvbkVsZW1lbnRcbiAqL1xuXG5jb25zdCBFUFNJTE9OID0gMC4wMDE7XG5jb25zdCBjbGFtcCA9ICh4LCBmcm9tLCB0bykgPT4gTWF0aC5taW4odG8sIE1hdGgubWF4KGZyb20sIHgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3t2YWx1ZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IGxpbWl0XG4gKiBAcGFyYW0ge251bWJlcn0gaGl0U2l6ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGluTGltaXQgPSAobGltaXQsIGhpdFNpemUpID0+IGxpbWl0LnZhbHVlID49IGxpbWl0LnN0YXJ0IC0gaGl0U2l6ZSAmJiBsaW1pdC52YWx1ZSA8PSBsaW1pdC5lbmQgKyBoaXRTaXplO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tXG4gKiBAcGFyYW0ge251bWJlcn0gdG9cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wQWxsKG9iaiwgZnJvbSwgdG8pIHtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgIG9ialtrZXldID0gY2xhbXAob2JqW2tleV0sIGZyb20sIHRvKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gKiBAcGFyYW0ge1BvaW50fSBjZW50ZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaXRTaXplXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaW5Qb2ludFJhbmdlKHBvaW50LCBjZW50ZXIsIHJhZGl1cywgaGl0U2l6ZSkge1xuICBpZiAoIXBvaW50IHx8ICFjZW50ZXIgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChNYXRoLnBvdyhwb2ludC54IC0gY2VudGVyLngsIDIpICsgTWF0aC5wb3cocG9pbnQueSAtIGNlbnRlci55LCAyKSkgPD0gTWF0aC5wb3cocmFkaXVzICsgaGl0U2l6ZSwgMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyfX0gcmVjdFxuICogQHBhcmFtIHtJbnRlcmFjdGlvbkF4aXN9IGF4aXNcbiAqIEBwYXJhbSB7e2JvcmRlcldpZHRoOiBudW1iZXIsIGhpdFRvbGVyYW5jZTogbnVtYmVyfX0gaGl0c2l6ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGluQm94UmFuZ2UocG9pbnQsIHt4LCB5LCB4MiwgeTJ9LCBheGlzLCB7Ym9yZGVyV2lkdGgsIGhpdFRvbGVyYW5jZX0pIHtcbiAgY29uc3QgaGl0U2l6ZSA9IChib3JkZXJXaWR0aCArIGhpdFRvbGVyYW5jZSkgLyAyO1xuICBjb25zdCBpblJhbmdlWCA9IHBvaW50LnggPj0geCAtIGhpdFNpemUgLSBFUFNJTE9OICYmIHBvaW50LnggPD0geDIgKyBoaXRTaXplICsgRVBTSUxPTjtcbiAgY29uc3QgaW5SYW5nZVkgPSBwb2ludC55ID49IHkgLSBoaXRTaXplIC0gRVBTSUxPTiAmJiBwb2ludC55IDw9IHkyICsgaGl0U2l6ZSArIEVQU0lMT047XG4gIGlmIChheGlzID09PSAneCcpIHtcbiAgICByZXR1cm4gaW5SYW5nZVg7XG4gIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgcmV0dXJuIGluUmFuZ2VZO1xuICB9XG4gIHJldHVybiBpblJhbmdlWCAmJiBpblJhbmdlWTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICogQHBhcmFtIHtyZWN0OiB7eDogbnVtYmVyLCB5OiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXJ9LCBjZW50ZXI6IHt4OiBudW1iZXIsIHk6IG51bWJlcn19IGVsZW1lbnRcbiAqIEBwYXJhbSB7SW50ZXJhY3Rpb25BeGlzfSBheGlzXG4gKiBAcGFyYW0ge3tyb3RhdGlvbjogbnVtYmVyLCBib3JkZXJXaWR0aDogbnVtYmVyLCBoaXRUb2xlcmFuY2U6IG51bWJlcn19XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaW5MYWJlbFJhbmdlKHBvaW50LCB7cmVjdCwgY2VudGVyfSwgYXhpcywge3JvdGF0aW9uLCBib3JkZXJXaWR0aCwgaGl0VG9sZXJhbmNlfSkge1xuICBjb25zdCByb3RQb2ludCA9IHJvdGF0ZWQocG9pbnQsIGNlbnRlciwgdG9SYWRpYW5zKC1yb3RhdGlvbikpO1xuICByZXR1cm4gaW5Cb3hSYW5nZShyb3RQb2ludCwgcmVjdCwgYXhpcywge2JvcmRlcldpZHRoLCBoaXRUb2xlcmFuY2V9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fubm90YXRpb25FbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZpbmFsUG9zaXRpb25cbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudENlbnRlclBvaW50KGVsZW1lbnQsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge2NlbnRlclgsIGNlbnRlcll9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ2NlbnRlclgnLCAnY2VudGVyWSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIHt4OiBjZW50ZXJYLCB5OiBjZW50ZXJZfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnXG4gKiBAcGFyYW0ge3N0cmluZ30gbWluXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdHJpY3Q9dHJ1ZV1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiByZXF1aXJlVmVyc2lvbihwa2csIG1pbiwgdmVyLCBzdHJpY3QgPSB0cnVlKSB7XG4gIGNvbnN0IHBhcnRzID0gdmVyLnNwbGl0KCcuJyk7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCByZXEgb2YgbWluLnNwbGl0KCcuJykpIHtcbiAgICBjb25zdCBhY3QgPSBwYXJ0c1tpKytdO1xuICAgIGlmIChwYXJzZUludChyZXEsIDEwKSA8IHBhcnNlSW50KGFjdCwgMTApKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGlzT2xkZXJQYXJ0KGFjdCwgcmVxKSkge1xuICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cGtnfSB2JHt2ZXJ9IGlzIG5vdCBzdXBwb3J0ZWQuIHYke21pbn0gb3IgbmV3ZXIgaXMgcmVxdWlyZWQuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBpc1BlcmNlbnRTdHJpbmcgPSAocykgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnICYmIHMuZW5kc1dpdGgoJyUnKTtcbmNvbnN0IHRvUGVyY2VudCA9IChzKSA9PiBwYXJzZUZsb2F0KHMpIC8gMTAwO1xuY29uc3QgdG9Qb3NpdGl2ZVBlcmNlbnQgPSAocykgPT4gY2xhbXAodG9QZXJjZW50KHMpLCAwLCAxKTtcblxuY29uc3QgYm94QXBwZXJpbmcgPSAoeCwgeSkgPT4gKHt4LCB5LCB4MjogeCwgeTI6IHksIHdpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcbmNvbnN0IGRlZmF1bHRJbml0QW5pbWF0aW9uID0ge1xuICBib3g6IChwcm9wZXJ0aWVzKSA9PiBib3hBcHBlcmluZyhwcm9wZXJ0aWVzLmNlbnRlclgsIHByb3BlcnRpZXMuY2VudGVyWSksXG4gIGRvdWdobnV0TGFiZWw6IChwcm9wZXJ0aWVzKSA9PiBib3hBcHBlcmluZyhwcm9wZXJ0aWVzLmNlbnRlclgsIHByb3BlcnRpZXMuY2VudGVyWSksXG4gIGVsbGlwc2U6IChwcm9wZXJ0aWVzKSA9PiAoe2NlbnRlclg6IHByb3BlcnRpZXMuY2VudGVyWCwgY2VudGVyWTogcHJvcGVydGllcy5jZW50ZXJYLCByYWRpdXM6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9KSxcbiAgbGFiZWw6IChwcm9wZXJ0aWVzKSA9PiBib3hBcHBlcmluZyhwcm9wZXJ0aWVzLmNlbnRlclgsIHByb3BlcnRpZXMuY2VudGVyWSksXG4gIGxpbmU6IChwcm9wZXJ0aWVzKSA9PiBib3hBcHBlcmluZyhwcm9wZXJ0aWVzLngsIHByb3BlcnRpZXMueSksXG4gIHBvaW50OiAocHJvcGVydGllcykgPT4gKHtjZW50ZXJYOiBwcm9wZXJ0aWVzLmNlbnRlclgsIGNlbnRlclk6IHByb3BlcnRpZXMuY2VudGVyWSwgcmFkaXVzOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwfSksXG4gIHBvbHlnb246IChwcm9wZXJ0aWVzKSA9PiBib3hBcHBlcmluZyhwcm9wZXJ0aWVzLmNlbnRlclgsIHByb3BlcnRpZXMuY2VudGVyWSlcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2NoYXJ0LmpzJykuRm9udFNwZWMgfSBGb250U3BlY1xuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2NoYXJ0LmpzJykuUG9pbnQgfSBQb2ludFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2NoYXJ0LmpzJykuUGFkZGluZyB9IFBhZGRpbmdcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9lbGVtZW50JykuQW5ub3RhdGlvbkJveE1vZGVsIH0gQW5ub3RhdGlvbkJveE1vZGVsXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvZWxlbWVudCcpLkFubm90YXRpb25FbGVtZW50IH0gQW5ub3RhdGlvbkVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9vcHRpb25zJykuQW5ub3RhdGlvblBvaW50Q29vcmRpbmF0ZXMgfSBBbm5vdGF0aW9uUG9pbnRDb29yZGluYXRlc1xuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2xhYmVsJykuQ29yZUxhYmVsT3B0aW9ucyB9IENvcmVMYWJlbE9wdGlvbnNcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9sYWJlbCcpLkxhYmVsUG9zaXRpb25PYmplY3QgfSBMYWJlbFBvc2l0aW9uT2JqZWN0XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBwb3NpdGlvblxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihzaXplLCBwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgaWYgKGlzUGVyY2VudFN0cmluZyhwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gdG9Qb3NpdGl2ZVBlcmNlbnQocG9zaXRpb24pICogc2l6ZTtcbiAgfVxuICByZXR1cm4gc2l6ZSAvIDI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Bvc2l0aXZlUGVyY2VudD10cnVlXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0U2l6ZShzaXplLCB2YWx1ZSwgcG9zaXRpdmVQZXJjZW50ID0gdHJ1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc1BlcmNlbnRTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIChwb3NpdGl2ZVBlcmNlbnQgPyB0b1Bvc2l0aXZlUGVyY2VudCh2YWx1ZSkgOiB0b1BlcmNlbnQodmFsdWUpKSAqIHNpemU7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8qKlxuICogQHBhcmFtIHt7eDogbnVtYmVyLCB3aWR0aDogbnVtYmVyfX0gc2l6ZVxuICogQHBhcmFtIHtDb3JlTGFiZWxPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0QWxpZ25tZW50KHNpemUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHRleHRBbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduO1xuICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHJldHVybiB4ICsgd2lkdGggLyAyO1xuICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2VuZCcgfHwgdGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuIHggKyB3aWR0aDtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICogQHBhcmFtIHt7aGVpZ2h0OiBudW1iZXIsIHdpZHRoOiBudW1iZXJ9fSBsYWJlbFNpemVcbiAqIEBwYXJhbSB7e2JvcmRlcldpZHRoOiBudW1iZXIsIHBvc2l0aW9uOiB7TGFiZWxQb3NpdGlvbk9iamVjdHxzdHJpbmd9LCB4QWRqdXN0OiBudW1iZXIsIHlBZGp1c3Q6IG51bWJlcn19IG9wdGlvbnNcbiAqIEBwYXJhbSB7UGFkZGluZ3x1bmRlZmluZWR9IHBhZGRpbmdcbiAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBjZW50ZXJYOiBudW1iZXIsIGNlbnRlclk6IG51bWJlcn19XG4gKi9cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFJlY3RhbmdsZShwb2ludCwgbGFiZWxTaXplLCB7Ym9yZGVyV2lkdGgsIHBvc2l0aW9uLCB4QWRqdXN0LCB5QWRqdXN0fSwgcGFkZGluZykge1xuICBjb25zdCBoYXNQYWRkaW5nID0gaXNPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplLndpZHRoICsgKGhhc1BhZGRpbmcgPyBwYWRkaW5nLndpZHRoIDogMCkgKyBib3JkZXJXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplLmhlaWdodCArIChoYXNQYWRkaW5nID8gcGFkZGluZy5oZWlnaHQgOiAwKSArIGJvcmRlcldpZHRoO1xuICBjb25zdCBwb3NpdGlvbk9iaiA9IHRvUG9zaXRpb24ocG9zaXRpb24pO1xuICBjb25zdCB4ID0gY2FsY3VsYXRlTGFiZWxQb3NpdGlvbiQxKHBvaW50LngsIHdpZHRoLCB4QWRqdXN0LCBwb3NpdGlvbk9iai54KTtcbiAgY29uc3QgeSA9IGNhbGN1bGF0ZUxhYmVsUG9zaXRpb24kMShwb2ludC55LCBoZWlnaHQsIHlBZGp1c3QsIHBvc2l0aW9uT2JqLnkpO1xuXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGNlbnRlclg6IHggKyB3aWR0aCAvIDIsXG4gICAgY2VudGVyWTogeSArIGhlaWdodCAvIDJcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xhYmVsUG9zaXRpb25PYmplY3R8c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqIEByZXR1cm5zIHtMYWJlbFBvc2l0aW9uT2JqZWN0fVxuICovXG5mdW5jdGlvbiB0b1Bvc2l0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUgPSAnY2VudGVyJykge1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHZhbHVlT3JEZWZhdWx0KHZhbHVlLngsIGRlZmF1bHRWYWx1ZSksXG4gICAgICB5OiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZS55LCBkZWZhdWx0VmFsdWUpLFxuICAgIH07XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB2YWx1ZSxcbiAgICB5OiB2YWx1ZVxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29yZUxhYmVsT3B0aW9uc30gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IGZpdFJhdGlvXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3Qgc2hvdWxkRml0ID0gKG9wdGlvbnMsIGZpdFJhdGlvKSA9PiBvcHRpb25zICYmIG9wdGlvbnMuYXV0b0ZpdCAmJiBmaXRSYXRpbyA8IDE7XG5cbi8qKlxuICogQHBhcmFtIHtDb3JlTGFiZWxPcHRpb25zfSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gZml0UmF0aW9cbiAqIEByZXR1cm5zIHtGb250U3BlY1tdfVxuICovXG5mdW5jdGlvbiB0b0ZvbnRzKG9wdGlvbnMsIGZpdFJhdGlvKSB7XG4gIGNvbnN0IG9wdEZvbnQgPSBvcHRpb25zLmZvbnQ7XG4gIGNvbnN0IGZvbnRzID0gaXNBcnJheShvcHRGb250KSA/IG9wdEZvbnQgOiBbb3B0Rm9udF07XG4gIGlmIChzaG91bGRGaXQob3B0aW9ucywgZml0UmF0aW8pKSB7XG4gICAgcmV0dXJuIGZvbnRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICBjb25zdCBmb250ID0gdG9Gb250KGYpO1xuICAgICAgZm9udC5zaXplID0gTWF0aC5mbG9vcihmLnNpemUgKiBmaXRSYXRpbyk7XG4gICAgICBmb250LmxpbmVIZWlnaHQgPSBmLmxpbmVIZWlnaHQ7XG4gICAgICByZXR1cm4gdG9Gb250KGZvbnQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmb250cy5tYXAoZiA9PiB0b0ZvbnQoZikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QW5ub3RhdGlvblBvaW50Q29vcmRpbmF0ZXN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0JvdW5kVG9Qb2ludChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zICYmIChkZWZpbmVkKG9wdGlvbnMueFZhbHVlKSB8fCBkZWZpbmVkKG9wdGlvbnMueVZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsUG9zaXRpb24kMShzdGFydCwgc2l6ZSwgYWRqdXN0ID0gMCwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIHN0YXJ0IC0gZ2V0UmVsYXRpdmVQb3NpdGlvbihzaXplLCBwb3NpdGlvbikgKyBhZGp1c3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7QW5ub3RhdGlvbkJveE1vZGVsfSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge0NvcmVBbm5vdGF0aW9uT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0Fubm90YXRpb25FbGVtZW50fVxuICovXG5mdW5jdGlvbiBpbml0QW5pbWF0aW9uUHJvcGVydGllcyhjaGFydCwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBjb25zdCBpbml0QW5pbSA9IG9wdGlvbnMuaW5pdDtcbiAgaWYgKCFpbml0QW5pbSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpbml0QW5pbSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBhcHBseURlZmF1bHQocHJvcGVydGllcywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGV4ZWNDYWxsYmFjayhjaGFydCwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IGhvb2tzXG4gKiBAcGFyYW0ge09iamVjdH0gaG9va3NDb250YWluZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBsb2FkSG9va3Mob3B0aW9ucywgaG9va3MsIGhvb2tzQ29udGFpbmVyKSB7XG4gIGxldCBhY3RpdmF0ZWQgPSBmYWxzZTtcbiAgaG9va3MuZm9yRWFjaChob29rID0+IHtcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zW2hvb2tdKSkge1xuICAgICAgYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgIGhvb2tzQ29udGFpbmVyW2hvb2tdID0gb3B0aW9uc1tob29rXTtcbiAgICB9IGVsc2UgaWYgKGRlZmluZWQoaG9va3NDb250YWluZXJbaG9va10pKSB7XG4gICAgICBkZWxldGUgaG9va3NDb250YWluZXJbaG9va107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFjdGl2YXRlZDtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0KHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCAnbGluZSc7XG4gIHJldHVybiBkZWZhdWx0SW5pdEFuaW1hdGlvblt0eXBlXShwcm9wZXJ0aWVzKTtcbn1cblxuZnVuY3Rpb24gZXhlY0NhbGxiYWNrKGNoYXJ0LCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKG9wdGlvbnMuaW5pdCwgW3tjaGFydCwgcHJvcGVydGllcywgb3B0aW9uc31dKTtcbiAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBhcHBseURlZmF1bHQocHJvcGVydGllcywgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QocmVzdWx0KSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuY29uc3Qgd2lkdGhDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IG5vdFJhZGl1cyA9IChyYWRpdXMpID0+IGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDA7XG5jb25zdCBmb250c0tleSA9IChmb250cykgPT4gZm9udHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGl0ZW0pIHtcbiAgcHJldiArPSBpdGVtLnN0cmluZztcbiAgcmV0dXJuIHByZXY7XG59LCAnJyk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ2NoYXJ0LmpzJykuUG9pbnQgfSBQb2ludFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2xhYmVsJykuQ29yZUxhYmVsT3B0aW9ucyB9IENvcmVMYWJlbE9wdGlvbnNcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9vcHRpb25zJykuUG9pbnRBbm5vdGF0aW9uT3B0aW9ucyB9IFBvaW50QW5ub3RhdGlvbk9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIERldGVybWluZSBpZiBjb250ZW50IGlzIGFuIGltYWdlIG9yIGEgY2FudmFzLlxuICogQHBhcmFtIHsqfSBjb250ZW50XG4gKiBAcmV0dXJucyBib29sZWFufHVuZGVmaW5lZFxuICogQHRvZG8gbW92ZSB0aGlzIGZ1bmN0aW9uIHRvIGNoYXJ0LmpzIGhlbHBlcnNcbiAqL1xuZnVuY3Rpb24gaXNJbWFnZU9yQ2FudmFzKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgJiYgdHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRlbnQudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCB0aGUgdHJhbnNsYXRpb24gb24gdGhlIGNhbnZhcyBpZiB0aGUgcm90YXRpb24gbXVzdCBiZSBhcHBsaWVkLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIGNoYXJ0IGNhbnZhcyBjb250ZXh0XG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIHRoZSBwb2ludCBvZiB0cmFuc2xhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gcm90YXRpb24gKGluIGRlZ3JlZXMpIHRvIGFwcGx5XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZShjdHgsIHt4LCB5fSwgcm90YXRpb24pIHtcbiAgaWYgKHJvdGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjdHgucm90YXRlKHRvUmFkaWFucyhyb3RhdGlvbikpO1xuICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHNldEJvcmRlclN0eWxlKGN0eCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgY3R4LmxpbmVDYXAgPSBvcHRpb25zLmJvcmRlckNhcFN0eWxlIHx8ICdidXR0JztcbiAgICBjdHguc2V0TGluZURhc2gob3B0aW9ucy5ib3JkZXJEYXNoKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgY3R4LmxpbmVKb2luID0gb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUgfHwgJ21pdGVyJztcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gc2V0U2hhZG93U3R5bGUoY3R4LCBvcHRpb25zKSB7XG4gIGN0eC5zaGFkb3dDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZFNoYWRvd0NvbG9yO1xuICBjdHguc2hhZG93Qmx1ciA9IG9wdGlvbnMuc2hhZG93Qmx1cjtcbiAgY3R4LnNoYWRvd09mZnNldFggPSBvcHRpb25zLnNoYWRvd09mZnNldFg7XG4gIGN0eC5zaGFkb3dPZmZzZXRZID0gb3B0aW9ucy5zaGFkb3dPZmZzZXRZO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqIEBwYXJhbSB7Q29yZUxhYmVsT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gKi9cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBvcHRpb25zLmNvbnRlbnQ7XG4gIGlmIChpc0ltYWdlT3JDYW52YXMoY29udGVudCkpIHtcbiAgICBjb25zdCBzaXplID0ge1xuICAgICAgd2lkdGg6IGdldFNpemUoY29udGVudC53aWR0aCwgb3B0aW9ucy53aWR0aCksXG4gICAgICBoZWlnaHQ6IGdldFNpemUoY29udGVudC5oZWlnaHQsIG9wdGlvbnMuaGVpZ2h0KVxuICAgIH07XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgY29uc3QgZm9udHMgPSB0b0ZvbnRzKG9wdGlvbnMpO1xuICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdGlvbnMudGV4dFN0cm9rZVdpZHRoO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdO1xuICBjb25zdCBtYXBLZXkgPSBsaW5lcy5qb2luKCkgKyBmb250c0tleShmb250cykgKyBzdHJva2VXaWR0aCArIChjdHguX21lYXN1cmVUZXh0ID8gJy1zcHJpdGluZycgOiAnJyk7XG4gIGlmICghd2lkdGhDYWNoZS5oYXMobWFwS2V5KSkge1xuICAgIHdpZHRoQ2FjaGUuc2V0KG1hcEtleSwgY2FsY3VsYXRlTGFiZWxTaXplKGN0eCwgbGluZXMsIGZvbnRzLCBzdHJva2VXaWR0aCkpO1xuICB9XG4gIHJldHVybiB3aWR0aENhY2hlLmdldChtYXBLZXkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHJlY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGRyYXdCb3goY3R4LCByZWN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IHJlY3Q7XG4gIGN0eC5zYXZlKCk7XG4gIHNldFNoYWRvd1N0eWxlKGN0eCwgb3B0aW9ucyk7XG4gIGNvbnN0IHN0cm9rZSA9IHNldEJvcmRlclN0eWxlKGN0eCwgb3B0aW9ucyk7XG4gIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgeCwgeSwgdzogd2lkdGgsIGg6IGhlaWdodCxcbiAgICByYWRpdXM6IGNsYW1wQWxsKHRvVFJCTENvcm5lcnMob3B0aW9ucy5ib3JkZXJSYWRpdXMpLCAwLCBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIpXG4gIH0pO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5maWxsKCk7XG4gIGlmIChzdHJva2UpIHtcbiAgICBjdHguc2hhZG93Q29sb3IgPSBvcHRpb25zLmJvcmRlclNoYWRvd0NvbG9yO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHJlY3RcbiAqIEBwYXJhbSB7Q29yZUxhYmVsT3B0aW9uc30gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IGZpdFJhdGlvXG4gKi9cbmZ1bmN0aW9uIGRyYXdMYWJlbChjdHgsIHJlY3QsIG9wdGlvbnMsIGZpdFJhdGlvKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBvcHRpb25zLmNvbnRlbnQ7XG4gIGlmIChpc0ltYWdlT3JDYW52YXMoY29udGVudCkpIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdldE9wYWNpdHkob3B0aW9ucy5vcGFjaXR5LCBjb250ZW50LnN0eWxlLm9wYWNpdHkpO1xuICAgIGN0eC5kcmF3SW1hZ2UoY29udGVudCwgcmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsYWJlbHMgPSBpc0FycmF5KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XTtcbiAgY29uc3QgZm9udHMgPSB0b0ZvbnRzKG9wdGlvbnMsIGZpdFJhdGlvKTtcbiAgY29uc3Qgb3B0Q29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICBjb25zdCBjb2xvcnMgPSBpc0FycmF5KG9wdENvbG9yKSA/IG9wdENvbG9yIDogW29wdENvbG9yXTtcbiAgY29uc3QgeCA9IGNhbGN1bGF0ZVRleHRBbGlnbm1lbnQocmVjdCwgb3B0aW9ucyk7XG4gIGNvbnN0IHkgPSByZWN0LnkgKyBvcHRpb25zLnRleHRTdHJva2VXaWR0aCAvIDI7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgY3R4LnRleHRBbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduO1xuICBpZiAoc2V0VGV4dFN0cm9rZVN0eWxlKGN0eCwgb3B0aW9ucykpIHtcbiAgICBhcHBseUxhYmVsRGVjb3JhdGlvbihjdHgsIHt4LCB5fSwgbGFiZWxzLCBmb250cyk7XG4gIH1cbiAgYXBwbHlMYWJlbENvbnRlbnQoY3R4LCB7eCwgeX0sIGxhYmVscywge2ZvbnRzLCBjb2xvcnN9KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gc2V0VGV4dFN0cm9rZVN0eWxlKGN0eCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50ZXh0U3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM2MjcxMTEvZHJhd2luZy10ZXh0LXdpdGgtYW4tb3V0ZXItc3Ryb2tlLXdpdGgtaHRtbDVzLWNhbnZhc1xuICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSAyO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLnRleHRTdHJva2VXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLnRleHRTdHJva2VDb2xvcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqIEBwYXJhbSB7e3JhZGl1czogbnVtYmVyLCBvcHRpb25zOiBQb2ludEFubm90YXRpb25PcHRpb25zfX0gZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKi9cbmZ1bmN0aW9uIGRyYXdQb2ludChjdHgsIGVsZW1lbnQsIHgsIHkpIHtcbiAgY29uc3Qge3JhZGl1cywgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cbiAgaWYgKGlzSW1hZ2VPckNhbnZhcyhzdHlsZSkpIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobm90UmFkaXVzKHJhZGl1cykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZHJhd1BvaW50U3R5bGUoY3R4LCB7eCwgeSwgcmFkaXVzLCByb3RhdGlvbiwgc3R5bGUsIHJhZH0pO1xufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRTdHlsZShjdHgsIHt4LCB5LCByYWRpdXMsIHJvdGF0aW9uLCBzdHlsZSwgcmFkfSkge1xuICBsZXQgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgc3dpdGNoIChzdHlsZSkge1xuICAvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuICBkZWZhdWx0OlxuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAndHJpYW5nbGUnOlxuICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIC8vIE5PVEU6IHRoZSByb3VuZGVkIHJlY3QgaW1wbGVtZW50YXRpb24gY2hhbmdlZCB0byB1c2UgYGFyY2AgaW5zdGVhZCBvZlxuICAgIC8vIGBxdWFkcmF0aWNDdXJ2ZVRvYCBzaW5jZSBpdCBnZW5lcmF0ZXMgYmV0dGVyIHJlc3VsdHMgd2hlbiByZWN0IGlzXG4gICAgLy8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuICAgIC8vIGNsb3NlciBwcm9wb3J0aW9uIHRvIHRoZSBwcmV2aW91cyBpbXBsIGFuZCBpdCBpcyBpbnNjcmliZWQgaW4gdGhlXG4gICAgLy8gY2lyY2xlIHdpdGggYHJhZGl1c2AuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgZm9sbG93aW5nIFBSczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81ODU4XG4gICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgY3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgY3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0JzpcbiAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgY3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgY2FzZSAncmVjdFJvdCc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgY2FzZSAnY3Jvc3MnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3Rhcic6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnbGluZSc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnZGFzaCc6XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgYnJlYWs7XG4gIH1cblxuICBjdHguZmlsbCgpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFNpemUoY3R4LCBsaW5lcywgZm9udHMsIHN0cm9rZVdpZHRoKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGNvbnN0IGNvdW50ID0gbGluZXMubGVuZ3RoO1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgaGVpZ2h0ID0gc3Ryb2tlV2lkdGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGNvbnN0IGZvbnQgPSBmb250c1tNYXRoLm1pbihpLCBmb250cy5sZW5ndGggLSAxKV07XG4gICAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgICBjb25zdCB0ZXh0ID0gbGluZXNbaV07XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICsgc3Ryb2tlV2lkdGgpO1xuICAgIGhlaWdodCArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gYXBwbHlMYWJlbERlY29yYXRpb24oY3R4LCB7eCwgeX0sIGxhYmVscywgZm9udHMpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBsZXQgbGhzID0gMDtcbiAgbGFiZWxzLmZvckVhY2goZnVuY3Rpb24obCwgaSkge1xuICAgIGNvbnN0IGYgPSBmb250c1tNYXRoLm1pbihpLCBmb250cy5sZW5ndGggLSAxKV07XG4gICAgY29uc3QgbGggPSBmLmxpbmVIZWlnaHQ7XG4gICAgY3R4LmZvbnQgPSBmLnN0cmluZztcbiAgICBjdHguc3Ryb2tlVGV4dChsLCB4LCB5ICsgbGggLyAyICsgbGhzKTtcbiAgICBsaHMgKz0gbGg7XG4gIH0pO1xuICBjdHguc3Ryb2tlKCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TGFiZWxDb250ZW50KGN0eCwge3gsIHl9LCBsYWJlbHMsIHtmb250cywgY29sb3JzfSkge1xuICBsZXQgbGhzID0gMDtcbiAgbGFiZWxzLmZvckVhY2goZnVuY3Rpb24obCwgaSkge1xuICAgIGNvbnN0IGMgPSBjb2xvcnNbTWF0aC5taW4oaSwgY29sb3JzLmxlbmd0aCAtIDEpXTtcbiAgICBjb25zdCBmID0gZm9udHNbTWF0aC5taW4oaSwgZm9udHMubGVuZ3RoIC0gMSldO1xuICAgIGNvbnN0IGxoID0gZi5saW5lSGVpZ2h0O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguZm9udCA9IGYuc3RyaW5nO1xuICAgIGN0eC5maWxsU3R5bGUgPSBjO1xuICAgIGN0eC5maWxsVGV4dChsLCB4LCB5ICsgbGggLyAyICsgbGhzKTtcbiAgICBsaHMgKz0gbGg7XG4gICAgY3R4LmZpbGwoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE9wYWNpdHkodmFsdWUsIGVsZW1lbnRWYWx1ZSkge1xuICBjb25zdCBvcGFjaXR5ID0gaXNOdW1iZXIodmFsdWUpID8gdmFsdWUgOiBlbGVtZW50VmFsdWU7XG4gIHJldHVybiBpc051bWJlcihvcGFjaXR5KSA/IGNsYW1wKG9wYWNpdHksIDAsIDEpIDogMTtcbn1cblxuY29uc3QgcG9zaXRpb25zID0gWydsZWZ0JywgJ2JvdHRvbScsICd0b3AnLCAncmlnaHQnXTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvZWxlbWVudCcpLkFubm90YXRpb25FbGVtZW50IH0gQW5ub3RhdGlvbkVsZW1lbnRcbiAqL1xuXG4vKipcbiAqIERyYXdhIHRoZSBjYWxsb3V0IGNvbXBvbmVudCBmb3IgbGFiZWxzLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIGNoYXJ0IGNhbnZhcyBjb250ZXh0XG4gKiBAcGFyYW0ge0Fubm90YXRpb25FbGVtZW50fSBlbGVtZW50IC0gdGhlIGxhYmVsIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZHJhd0NhbGxvdXQoY3R4LCBlbGVtZW50KSB7XG4gIGNvbnN0IHtwb2ludFgsIHBvaW50WSwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCBjYWxsb3V0ID0gb3B0aW9ucy5jYWxsb3V0O1xuICBjb25zdCBjYWxsb3V0UG9zaXRpb24gPSBjYWxsb3V0ICYmIGNhbGxvdXQuZGlzcGxheSAmJiByZXNvbHZlQ2FsbG91dFBvc2l0aW9uKGVsZW1lbnQsIGNhbGxvdXQpO1xuICBpZiAoIWNhbGxvdXRQb3NpdGlvbiB8fCBpc1BvaW50SW5SYW5nZShlbGVtZW50LCBjYWxsb3V0LCBjYWxsb3V0UG9zaXRpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjb25zdCBzdHJva2UgPSBzZXRCb3JkZXJTdHlsZShjdHgsIGNhbGxvdXQpO1xuICBpZiAoIXN0cm9rZSkge1xuICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGNvbnN0IHtzZXBhcmF0b3JTdGFydCwgc2VwYXJhdG9yRW5kfSA9IGdldENhbGxvdXRTZXBhcmF0b3JDb29yZChlbGVtZW50LCBjYWxsb3V0UG9zaXRpb24pO1xuICBjb25zdCB7c2lkZVN0YXJ0LCBzaWRlRW5kfSA9IGdldENhbGxvdXRTaWRlQ29vcmQoZWxlbWVudCwgY2FsbG91dFBvc2l0aW9uLCBzZXBhcmF0b3JTdGFydCk7XG4gIGlmIChjYWxsb3V0Lm1hcmdpbiA+IDAgfHwgb3B0aW9ucy5ib3JkZXJXaWR0aCA9PT0gMCkge1xuICAgIGN0eC5tb3ZlVG8oc2VwYXJhdG9yU3RhcnQueCwgc2VwYXJhdG9yU3RhcnQueSk7XG4gICAgY3R4LmxpbmVUbyhzZXBhcmF0b3JFbmQueCwgc2VwYXJhdG9yRW5kLnkpO1xuICB9XG4gIGN0eC5tb3ZlVG8oc2lkZVN0YXJ0LngsIHNpZGVTdGFydC55KTtcbiAgY3R4LmxpbmVUbyhzaWRlRW5kLngsIHNpZGVFbmQueSk7XG4gIGNvbnN0IHJvdGF0ZWRQb2ludCA9IHJvdGF0ZWQoe3g6IHBvaW50WCwgeTogcG9pbnRZfSwgZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpLCB0b1JhZGlhbnMoLWVsZW1lbnQucm90YXRpb24pKTtcbiAgY3R4LmxpbmVUbyhyb3RhdGVkUG9pbnQueCwgcm90YXRlZFBvaW50LnkpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGdldENhbGxvdXRTZXBhcmF0b3JDb29yZChlbGVtZW50LCBwb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgeDIsIHkyfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IGFkanVzdCA9IGdldENhbGxvdXRTZXBhcmF0b3JBZGp1c3QoZWxlbWVudCwgcG9zaXRpb24pO1xuICBsZXQgc2VwYXJhdG9yU3RhcnQsIHNlcGFyYXRvckVuZDtcbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICBzZXBhcmF0b3JTdGFydCA9IHt4OiB4ICsgYWRqdXN0LCB5fTtcbiAgICBzZXBhcmF0b3JFbmQgPSB7eDogc2VwYXJhdG9yU3RhcnQueCwgeTogeTJ9O1xuICB9IGVsc2Uge1xuICAgIC8vICBwb3NpdGlvbiAndG9wJyBvciAnYm90dG9tJ1xuICAgIHNlcGFyYXRvclN0YXJ0ID0ge3gsIHk6IHkgKyBhZGp1c3R9O1xuICAgIHNlcGFyYXRvckVuZCA9IHt4OiB4MiwgeTogc2VwYXJhdG9yU3RhcnQueX07XG4gIH1cbiAgcmV0dXJuIHtzZXBhcmF0b3JTdGFydCwgc2VwYXJhdG9yRW5kfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FsbG91dFNlcGFyYXRvckFkanVzdChlbGVtZW50LCBwb3NpdGlvbikge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCBhZGp1c3QgPSBvcHRpb25zLmNhbGxvdXQubWFyZ2luICsgb3B0aW9ucy5ib3JkZXJXaWR0aCAvIDI7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiB3aWR0aCArIGFkanVzdDtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gaGVpZ2h0ICsgYWRqdXN0O1xuICB9XG4gIHJldHVybiAtYWRqdXN0O1xufVxuXG5mdW5jdGlvbiBnZXRDYWxsb3V0U2lkZUNvb3JkKGVsZW1lbnQsIHBvc2l0aW9uLCBzZXBhcmF0b3JTdGFydCkge1xuICBjb25zdCB7eSwgd2lkdGgsIGhlaWdodCwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMuY2FsbG91dC5zdGFydDtcbiAgY29uc3Qgc2lkZSA9IGdldENhbGxvdXRTaWRlQWRqdXN0KHBvc2l0aW9uLCBvcHRpb25zLmNhbGxvdXQpO1xuICBsZXQgc2lkZVN0YXJ0LCBzaWRlRW5kO1xuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHNpZGVTdGFydCA9IHt4OiBzZXBhcmF0b3JTdGFydC54LCB5OiB5ICsgZ2V0U2l6ZShoZWlnaHQsIHN0YXJ0KX07XG4gICAgc2lkZUVuZCA9IHt4OiBzaWRlU3RhcnQueCArIHNpZGUsIHk6IHNpZGVTdGFydC55fTtcbiAgfSBlbHNlIHtcbiAgICAvLyAgcG9zaXRpb24gJ3RvcCcgb3IgJ2JvdHRvbSdcbiAgICBzaWRlU3RhcnQgPSB7eDogc2VwYXJhdG9yU3RhcnQueCArIGdldFNpemUod2lkdGgsIHN0YXJ0KSwgeTogc2VwYXJhdG9yU3RhcnQueX07XG4gICAgc2lkZUVuZCA9IHt4OiBzaWRlU3RhcnQueCwgeTogc2lkZVN0YXJ0LnkgKyBzaWRlfTtcbiAgfVxuICByZXR1cm4ge3NpZGVTdGFydCwgc2lkZUVuZH07XG59XG5cbmZ1bmN0aW9uIGdldENhbGxvdXRTaWRlQWRqdXN0KHBvc2l0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNpZGUgPSBvcHRpb25zLnNpZGU7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAndG9wJykge1xuICAgIHJldHVybiAtc2lkZTtcbiAgfVxuICByZXR1cm4gc2lkZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNhbGxvdXRQb3NpdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgaWYgKHBvc2l0aW9ucy5pbmNsdWRlcyhwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVDYWxsb3V0QXV0b1Bvc2l0aW9uKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ2FsbG91dEF1dG9Qb3NpdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHt4LCB5LCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIHBvaW50WCwgcG9pbnRZLCBjZW50ZXJYLCBjZW50ZXJZLCByb3RhdGlvbn0gPSBlbGVtZW50O1xuICBjb25zdCBjZW50ZXIgPSB7eDogY2VudGVyWCwgeTogY2VudGVyWX07XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgY29uc3QgeEFkanVzdCA9IGdldFNpemUod2lkdGgsIHN0YXJ0KTtcbiAgY29uc3QgeUFkanVzdCA9IGdldFNpemUoaGVpZ2h0LCBzdGFydCk7XG4gIGNvbnN0IHhQb2ludHMgPSBbeCwgeCArIHhBZGp1c3QsIHggKyB4QWRqdXN0LCB4Ml07XG4gIGNvbnN0IHlQb2ludHMgPSBbeSArIHlBZGp1c3QsIHkyLCB5LCB5Ml07XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgNDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHJvdGF0ZWRQb2ludCA9IHJvdGF0ZWQoe3g6IHhQb2ludHNbaW5kZXhdLCB5OiB5UG9pbnRzW2luZGV4XX0sIGNlbnRlciwgdG9SYWRpYW5zKHJvdGF0aW9uKSk7XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uc1tpbmRleF0sXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHJvdGF0ZWRQb2ludCwge3g6IHBvaW50WCwgeTogcG9pbnRZfSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlKVswXS5wb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluUmFuZ2UoZWxlbWVudCwgY2FsbG91dCwgcG9zaXRpb24pIHtcbiAgY29uc3Qge3BvaW50WCwgcG9pbnRZfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IG1hcmdpbiA9IGNhbGxvdXQubWFyZ2luO1xuICBsZXQgeCA9IHBvaW50WDtcbiAgbGV0IHkgPSBwb2ludFk7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCArPSBtYXJnaW47XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IG1hcmdpbjtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICB5ICs9IG1hcmdpbjtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IG1hcmdpbjtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5pblJhbmdlKHgsIHkpO1xufVxuXG5jb25zdCBsaW1pdGVkTGluZVNjYWxlID0ge1xuICB4U2NhbGVJRDoge21pbjogJ3hNaW4nLCBtYXg6ICd4TWF4Jywgc3RhcnQ6ICdsZWZ0JywgZW5kOiAncmlnaHQnLCBzdGFydFByb3A6ICd4JywgZW5kUHJvcDogJ3gyJ30sXG4gIHlTY2FsZUlEOiB7bWluOiAneU1pbicsIG1heDogJ3lNYXgnLCBzdGFydDogJ2JvdHRvbScsIGVuZDogJ3RvcCcsIHN0YXJ0UHJvcDogJ3knLCBlbmRQcm9wOiAneTInfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcImNoYXJ0LmpzXCIpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiY2hhcnQuanNcIikuU2NhbGUgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoXCJjaGFydC5qc1wiKS5Qb2ludCB9IFBvaW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvZWxlbWVudCcpLkFubm90YXRpb25Cb3hNb2RlbCB9IEFubm90YXRpb25Cb3hNb2RlbFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL29wdGlvbnMnKS5Db3JlQW5ub3RhdGlvbk9wdGlvbnMgfSBDb3JlQW5ub3RhdGlvbk9wdGlvbnNcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9vcHRpb25zJykuTGluZUFubm90YXRpb25PcHRpb25zIH0gTGluZUFubm90YXRpb25PcHRpb25zXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvb3B0aW9ucycpLlBvaW50QW5ub3RhdGlvbk9wdGlvbnMgfSBQb2ludEFubm90YXRpb25PcHRpb25zXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvb3B0aW9ucycpLlBvbHlnb25Bbm5vdGF0aW9uT3B0aW9ucyB9IFBvbHlnb25Bbm5vdGF0aW9uT3B0aW9uc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYWxsYmFja1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2NhbGVWYWx1ZShzY2FsZSwgdmFsdWUsIGZhbGxiYWNrKSB7XG4gIHZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogc2NhbGUucGFyc2UodmFsdWUpO1xuICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuLyoqXG4gKiBTZWFyY2ggdGhlIHNjYWxlIGRlZmluZWQgaW4gY2hhcnRqcyBieSB0aGUgYXhpcyByZWxhdGVkIHRvIHRoZSBhbm5vdGF0aW9uIG9wdGlvbnMga2V5LlxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IFNjYWxlIH19IHNjYWxlc1xuICogQHBhcmFtIHtDb3JlQW5ub3RhdGlvbk9wdGlvbnN9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJldHJpZXZlU2NhbGVJRChzY2FsZXMsIG9wdGlvbnMsIGtleSkge1xuICBjb25zdCBzY2FsZUlEID0gb3B0aW9uc1trZXldO1xuICBpZiAoc2NhbGVJRCB8fCBrZXkgPT09ICdzY2FsZUlEJykge1xuICAgIHJldHVybiBzY2FsZUlEO1xuICB9XG4gIGNvbnN0IGF4aXMgPSBrZXkuY2hhckF0KDApO1xuICBjb25zdCBheGVzID0gT2JqZWN0LnZhbHVlcyhzY2FsZXMpLmZpbHRlcigoc2NhbGUpID0+IHNjYWxlLmF4aXMgJiYgc2NhbGUuYXhpcyA9PT0gYXhpcyk7XG4gIGlmIChheGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBheGVzWzBdLmlkO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gb3B0aW9uc1xuICogQHJldHVybnMge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn18dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBnZXREaW1lbnNpb25CeVNjYWxlKHNjYWxlLCBvcHRpb25zKSB7XG4gIGlmIChzY2FsZSkge1xuICAgIGNvbnN0IHJldmVyc2UgPSBzY2FsZS5vcHRpb25zLnJldmVyc2U7XG4gICAgY29uc3Qgc3RhcnQgPSBzY2FsZVZhbHVlKHNjYWxlLCBvcHRpb25zLm1pbiwgcmV2ZXJzZSA/IG9wdGlvbnMuZW5kIDogb3B0aW9ucy5zdGFydCk7XG4gICAgY29uc3QgZW5kID0gc2NhbGVWYWx1ZShzY2FsZSwgb3B0aW9ucy5tYXgsIHJldmVyc2UgPyBvcHRpb25zLnN0YXJ0IDogb3B0aW9ucy5lbmQpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtDb3JlQW5ub3RhdGlvbk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhcnRQb2ludChjaGFydCwgb3B0aW9ucykge1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGNvbnN0IHhTY2FsZSA9IHNjYWxlc1tyZXRyaWV2ZVNjYWxlSUQoc2NhbGVzLCBvcHRpb25zLCAneFNjYWxlSUQnKV07XG4gIGNvbnN0IHlTY2FsZSA9IHNjYWxlc1tyZXRyaWV2ZVNjYWxlSUQoc2NhbGVzLCBvcHRpb25zLCAneVNjYWxlSUQnKV07XG4gIGxldCB4ID0gY2hhcnRBcmVhLndpZHRoIC8gMjtcbiAgbGV0IHkgPSBjaGFydEFyZWEuaGVpZ2h0IC8gMjtcblxuICBpZiAoeFNjYWxlKSB7XG4gICAgeCA9IHNjYWxlVmFsdWUoeFNjYWxlLCBvcHRpb25zLnhWYWx1ZSwgeFNjYWxlLmxlZnQgKyB4U2NhbGUud2lkdGggLyAyKTtcbiAgfVxuXG4gIGlmICh5U2NhbGUpIHtcbiAgICB5ID0gc2NhbGVWYWx1ZSh5U2NhbGUsIG9wdGlvbnMueVZhbHVlLCB5U2NhbGUudG9wICsgeVNjYWxlLmhlaWdodCAvIDIpO1xuICB9XG4gIHJldHVybiB7eCwgeX07XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7Q29yZUFubm90YXRpb25PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QW5ub3RhdGlvbkJveE1vZGVsfVxuICovXG5mdW5jdGlvbiByZXNvbHZlQm94UHJvcGVydGllcyhjaGFydCwgb3B0aW9ucykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIGNvbnN0IHhTY2FsZSA9IHNjYWxlc1tyZXRyaWV2ZVNjYWxlSUQoc2NhbGVzLCBvcHRpb25zLCAneFNjYWxlSUQnKV07XG4gIGNvbnN0IHlTY2FsZSA9IHNjYWxlc1tyZXRyaWV2ZVNjYWxlSUQoc2NhbGVzLCBvcHRpb25zLCAneVNjYWxlSUQnKV07XG5cbiAgaWYgKCF4U2NhbGUgJiYgIXlTY2FsZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGxldCB7bGVmdDogeCwgcmlnaHQ6IHgyfSA9IHhTY2FsZSB8fCBjaGFydC5jaGFydEFyZWE7XG4gIGxldCB7dG9wOiB5LCBib3R0b206IHkyfSA9IHlTY2FsZSB8fCBjaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHhEaW0gPSBnZXRDaGFydERpbWVuc2lvbkJ5U2NhbGUoeFNjYWxlLCB7bWluOiBvcHRpb25zLnhNaW4sIG1heDogb3B0aW9ucy54TWF4LCBzdGFydDogeCwgZW5kOiB4Mn0pO1xuICB4ID0geERpbS5zdGFydDtcbiAgeDIgPSB4RGltLmVuZDtcbiAgY29uc3QgeURpbSA9IGdldENoYXJ0RGltZW5zaW9uQnlTY2FsZSh5U2NhbGUsIHttaW46IG9wdGlvbnMueU1pbiwgbWF4OiBvcHRpb25zLnlNYXgsIHN0YXJ0OiB5MiwgZW5kOiB5fSk7XG4gIHkgPSB5RGltLnN0YXJ0O1xuICB5MiA9IHlEaW0uZW5kO1xuXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHgyLFxuICAgIHkyLFxuICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgaGVpZ2h0OiB5MiAtIHksXG4gICAgY2VudGVyWDogeCArICh4MiAtIHgpIC8gMixcbiAgICBjZW50ZXJZOiB5ICsgKHkyIC0geSkgLyAyXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7UG9pbnRBbm5vdGF0aW9uT3B0aW9uc3xQb2x5Z29uQW5ub3RhdGlvbk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBbm5vdGF0aW9uQm94TW9kZWx9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVQb2ludFByb3BlcnRpZXMoY2hhcnQsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc0JvdW5kVG9Qb2ludChvcHRpb25zKSkge1xuICAgIGNvbnN0IGJveCA9IHJlc29sdmVCb3hQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gICAgaWYgKCFyYWRpdXMgfHwgaXNOYU4ocmFkaXVzKSkge1xuICAgICAgcmFkaXVzID0gTWF0aC5taW4oYm94LndpZHRoLCBib3guaGVpZ2h0KSAvIDI7XG4gICAgICBvcHRpb25zLnJhZGl1cyA9IHJhZGl1cztcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IHJhZGl1cyAqIDI7XG4gICAgY29uc3QgYWRqdXN0Q2VudGVyWCA9IGJveC5jZW50ZXJYICsgb3B0aW9ucy54QWRqdXN0O1xuICAgIGNvbnN0IGFkanVzdENlbnRlclkgPSBib3guY2VudGVyWSArIG9wdGlvbnMueUFkanVzdDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYWRqdXN0Q2VudGVyWCAtIHJhZGl1cyxcbiAgICAgIHk6IGFkanVzdENlbnRlclkgLSByYWRpdXMsXG4gICAgICB4MjogYWRqdXN0Q2VudGVyWCArIHJhZGl1cyxcbiAgICAgIHkyOiBhZGp1c3RDZW50ZXJZICsgcmFkaXVzLFxuICAgICAgY2VudGVyWDogYWRqdXN0Q2VudGVyWCxcbiAgICAgIGNlbnRlclk6IGFkanVzdENlbnRlclksXG4gICAgICB3aWR0aDogc2l6ZSxcbiAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgIHJhZGl1c1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGdldENoYXJ0Q2lyY2xlKGNoYXJ0LCBvcHRpb25zKTtcbn1cbi8qKlxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7TGluZUFubm90YXRpb25PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QW5ub3RhdGlvbkJveE1vZGVsfVxuICovXG5mdW5jdGlvbiByZXNvbHZlTGluZVByb3BlcnRpZXMoY2hhcnQsIG9wdGlvbnMpIHtcbiAgY29uc3Qge3NjYWxlcywgY2hhcnRBcmVhfSA9IGNoYXJ0O1xuICBjb25zdCBzY2FsZSA9IHNjYWxlc1tvcHRpb25zLnNjYWxlSURdO1xuICBjb25zdCBhcmVhID0ge3g6IGNoYXJ0QXJlYS5sZWZ0LCB5OiBjaGFydEFyZWEudG9wLCB4MjogY2hhcnRBcmVhLnJpZ2h0LCB5MjogY2hhcnRBcmVhLmJvdHRvbX07XG5cbiAgaWYgKHNjYWxlKSB7XG4gICAgcmVzb2x2ZUZ1bGxMaW5lUHJvcGVydGllcyhzY2FsZSwgYXJlYSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZUxpbWl0ZWRMaW5lUHJvcGVydGllcyhzY2FsZXMsIGFyZWEsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge0NvcmVBbm5vdGF0aW9uT3B0aW9uc30gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbY2VudGVyQmFzZWQ9ZmFsc2VdXG4gKiBAcmV0dXJucyB7QW5ub3RhdGlvbkJveE1vZGVsfVxuICovXG5mdW5jdGlvbiByZXNvbHZlQm94QW5kTGFiZWxQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSByZXNvbHZlQm94UHJvcGVydGllcyhjaGFydCwgb3B0aW9ucyk7XG4gIHByb3BlcnRpZXMuaW5pdFByb3BlcnRpZXMgPSBpbml0QW5pbWF0aW9uUHJvcGVydGllcyhjaGFydCwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gIHByb3BlcnRpZXMuZWxlbWVudHMgPSBbe1xuICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgb3B0aW9uU2NvcGU6ICdsYWJlbCcsXG4gICAgcHJvcGVydGllczogcmVzb2x2ZUxhYmVsRWxlbWVudFByb3BlcnRpZXMkMShjaGFydCwgcHJvcGVydGllcywgb3B0aW9ucyksXG4gICAgaW5pdFByb3BlcnRpZXM6IHByb3BlcnRpZXMuaW5pdFByb3BlcnRpZXNcbiAgfV07XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFydENpcmNsZShjaGFydCwgb3B0aW9ucykge1xuICBjb25zdCBwb2ludCA9IGdldENoYXJ0UG9pbnQoY2hhcnQsIG9wdGlvbnMpO1xuICBjb25zdCBzaXplID0gb3B0aW9ucy5yYWRpdXMgKiAyO1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50LnggLSBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMueEFkanVzdCxcbiAgICB5OiBwb2ludC55IC0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLnlBZGp1c3QsXG4gICAgeDI6IHBvaW50LnggKyBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMueEFkanVzdCxcbiAgICB5MjogcG9pbnQueSArIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy55QWRqdXN0LFxuICAgIGNlbnRlclg6IHBvaW50LnggKyBvcHRpb25zLnhBZGp1c3QsXG4gICAgY2VudGVyWTogcG9pbnQueSArIG9wdGlvbnMueUFkanVzdCxcbiAgICByYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIGhlaWdodDogc2l6ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDaGFydERpbWVuc2lvbkJ5U2NhbGUoc2NhbGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gZ2V0RGltZW5zaW9uQnlTY2FsZShzY2FsZSwgb3B0aW9ucykgfHwgb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogTWF0aC5taW4ocmVzdWx0LnN0YXJ0LCByZXN1bHQuZW5kKSxcbiAgICBlbmQ6IE1hdGgubWF4KHJlc3VsdC5zdGFydCwgcmVzdWx0LmVuZClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZ1bGxMaW5lUHJvcGVydGllcyhzY2FsZSwgYXJlYSwgb3B0aW9ucykge1xuICBjb25zdCBtaW4gPSBzY2FsZVZhbHVlKHNjYWxlLCBvcHRpb25zLnZhbHVlLCBOYU4pO1xuICBjb25zdCBtYXggPSBzY2FsZVZhbHVlKHNjYWxlLCBvcHRpb25zLmVuZFZhbHVlLCBtaW4pO1xuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICBhcmVhLnggPSBtaW47XG4gICAgYXJlYS54MiA9IG1heDtcbiAgfSBlbHNlIHtcbiAgICBhcmVhLnkgPSBtaW47XG4gICAgYXJlYS55MiA9IG1heDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTGltaXRlZExpbmVQcm9wZXJ0aWVzKHNjYWxlcywgYXJlYSwgb3B0aW9ucykge1xuICBmb3IgKGNvbnN0IHNjYWxlSWQgb2YgT2JqZWN0LmtleXMobGltaXRlZExpbmVTY2FsZSkpIHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1tyZXRyaWV2ZVNjYWxlSUQoc2NhbGVzLCBvcHRpb25zLCBzY2FsZUlkKV07XG4gICAgaWYgKHNjYWxlKSB7XG4gICAgICBjb25zdCB7bWluLCBtYXgsIHN0YXJ0LCBlbmQsIHN0YXJ0UHJvcCwgZW5kUHJvcH0gPSBsaW1pdGVkTGluZVNjYWxlW3NjYWxlSWRdO1xuICAgICAgY29uc3QgZGltID0gZ2V0RGltZW5zaW9uQnlTY2FsZShzY2FsZSwge21pbjogb3B0aW9uc1ttaW5dLCBtYXg6IG9wdGlvbnNbbWF4XSwgc3RhcnQ6IHNjYWxlW3N0YXJ0XSwgZW5kOiBzY2FsZVtlbmRdfSk7XG4gICAgICBhcmVhW3N0YXJ0UHJvcF0gPSBkaW0uc3RhcnQ7XG4gICAgICBhcmVhW2VuZFByb3BdID0gZGltLmVuZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlWCh7cHJvcGVydGllcywgb3B0aW9uc30sIGxhYmVsU2l6ZSwgcG9zaXRpb24sIHBhZGRpbmcpIHtcbiAgY29uc3Qge3g6IHN0YXJ0LCB4MjogZW5kLCB3aWR0aDogc2l6ZX0gPSBwcm9wZXJ0aWVzO1xuICByZXR1cm4gY2FsY3VsYXRlUG9zaXRpb24oe3N0YXJ0LCBlbmQsIHNpemUsIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRofSwge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbi54LFxuICAgIHBhZGRpbmc6IHtzdGFydDogcGFkZGluZy5sZWZ0LCBlbmQ6IHBhZGRpbmcucmlnaHR9LFxuICAgIGFkanVzdDogb3B0aW9ucy5sYWJlbC54QWRqdXN0LFxuICAgIHNpemU6IGxhYmVsU2l6ZS53aWR0aFxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlWSh7cHJvcGVydGllcywgb3B0aW9uc30sIGxhYmVsU2l6ZSwgcG9zaXRpb24sIHBhZGRpbmcpIHtcbiAgY29uc3Qge3k6IHN0YXJ0LCB5MjogZW5kLCBoZWlnaHQ6IHNpemV9ID0gcHJvcGVydGllcztcbiAgcmV0dXJuIGNhbGN1bGF0ZVBvc2l0aW9uKHtzdGFydCwgZW5kLCBzaXplLCBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aH0sIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24ueSxcbiAgICBwYWRkaW5nOiB7c3RhcnQ6IHBhZGRpbmcudG9wLCBlbmQ6IHBhZGRpbmcuYm90dG9tfSxcbiAgICBhZGp1c3Q6IG9wdGlvbnMubGFiZWwueUFkanVzdCxcbiAgICBzaXplOiBsYWJlbFNpemUuaGVpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbihib3hPcHRzLCBsYWJlbE9wdHMpIHtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGJvcmRlcldpZHRofSA9IGJveE9wdHM7XG4gIGNvbnN0IHtwb3NpdGlvbiwgcGFkZGluZzoge3N0YXJ0OiBwYWRTdGFydCwgZW5kOiBwYWRFbmR9LCBhZGp1c3R9ID0gbGFiZWxPcHRzO1xuICBjb25zdCBhdmFpbGFibGVTaXplID0gZW5kIC0gYm9yZGVyV2lkdGggLSBzdGFydCAtIHBhZFN0YXJ0IC0gcGFkRW5kIC0gbGFiZWxPcHRzLnNpemU7XG4gIHJldHVybiBzdGFydCArIGJvcmRlcldpZHRoIC8gMiArIGFkanVzdCArIGdldFJlbGF0aXZlUG9zaXRpb24oYXZhaWxhYmxlU2l6ZSwgcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTGFiZWxFbGVtZW50UHJvcGVydGllcyQxKGNoYXJ0LCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxhYmVsID0gb3B0aW9ucy5sYWJlbDtcbiAgbGFiZWwuYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgbGFiZWwuY2FsbG91dC5kaXNwbGF5ID0gZmFsc2U7XG4gIGNvbnN0IHBvc2l0aW9uID0gdG9Qb3NpdGlvbihsYWJlbC5wb3NpdGlvbik7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcobGFiZWwucGFkZGluZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoY2hhcnQuY3R4LCBsYWJlbCk7XG4gIGNvbnN0IHggPSBjYWxjdWxhdGVYKHtwcm9wZXJ0aWVzLCBvcHRpb25zfSwgbGFiZWxTaXplLCBwb3NpdGlvbiwgcGFkZGluZyk7XG4gIGNvbnN0IHkgPSBjYWxjdWxhdGVZKHtwcm9wZXJ0aWVzLCBvcHRpb25zfSwgbGFiZWxTaXplLCBwb3NpdGlvbiwgcGFkZGluZyk7XG4gIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplLndpZHRoICsgcGFkZGluZy53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplLmhlaWdodCArIHBhZGRpbmcuaGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB4MjogeCArIHdpZHRoLFxuICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBjZW50ZXJYOiB4ICsgd2lkdGggLyAyLFxuICAgIGNlbnRlclk6IHkgKyBoZWlnaHQgLyAyLFxuICAgIHJvdGF0aW9uOiBsYWJlbC5yb3RhdGlvblxuICB9O1xuXG59XG5cbmNvbnN0IG1vdmVIb29rcyA9IFsnZW50ZXInLCAnbGVhdmUnXTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcImNoYXJ0LmpzXCIpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9vcHRpb25zJykuQW5ub3RhdGlvblBsdWdpbk9wdGlvbnMgfSBBbm5vdGF0aW9uUGx1Z2luT3B0aW9uc1xuICovXG5cbmNvbnN0IGV2ZW50SG9va3MgPSBtb3ZlSG9va3MuY29uY2F0KCdjbGljaycpO1xuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7QW5ub3RhdGlvblBsdWdpbk9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzKGNoYXJ0LCBzdGF0ZSwgb3B0aW9ucykge1xuICBzdGF0ZS5saXN0ZW5lZCA9IGxvYWRIb29rcyhvcHRpb25zLCBldmVudEhvb2tzLCBzdGF0ZS5saXN0ZW5lcnMpO1xuICBzdGF0ZS5tb3ZlTGlzdGVuZWQgPSBmYWxzZTtcblxuICBtb3ZlSG9va3MuZm9yRWFjaChob29rID0+IHtcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zW2hvb2tdKSkge1xuICAgICAgc3RhdGUubW92ZUxpc3RlbmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghc3RhdGUubGlzdGVuZWQgfHwgIXN0YXRlLm1vdmVMaXN0ZW5lZCkge1xuICAgIHN0YXRlLmFubm90YXRpb25zLmZvckVhY2goc2NvcGUgPT4ge1xuICAgICAgaWYgKCFzdGF0ZS5saXN0ZW5lZCAmJiBpc0Z1bmN0aW9uKHNjb3BlLmNsaWNrKSkge1xuICAgICAgICBzdGF0ZS5saXN0ZW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXN0YXRlLm1vdmVMaXN0ZW5lZCkge1xuICAgICAgICBtb3ZlSG9va3MuZm9yRWFjaChob29rID0+IHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihzY29wZVtob29rXSkpIHtcbiAgICAgICAgICAgIHN0YXRlLmxpc3RlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlLm1vdmVMaXN0ZW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtDaGFydEV2ZW50fSBldmVudFxuICogQHBhcmFtIHtBbm5vdGF0aW9uUGx1Z2luT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KHN0YXRlLCBldmVudCwgb3B0aW9ucykge1xuICBpZiAoc3RhdGUubGlzdGVuZWQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgIHJldHVybiBoYW5kbGVNb3ZlRXZlbnRzKHN0YXRlLCBldmVudCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgcmV0dXJuIGhhbmRsZUNsaWNrRXZlbnRzKHN0YXRlLCBldmVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudHMoc3RhdGUsIGV2ZW50LCBvcHRpb25zKSB7XG4gIGlmICghc3RhdGUubW92ZUxpc3RlbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGVsZW1lbnRzO1xuXG4gIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIGVsZW1lbnRzID0gZ2V0RWxlbWVudHMoc3RhdGUudmlzaWJsZUVsZW1lbnRzLCBldmVudCwgb3B0aW9ucy5pbnRlcmFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudHMgPSBbXTtcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzID0gc3RhdGUuaG92ZXJlZDtcbiAgc3RhdGUuaG92ZXJlZCA9IGVsZW1lbnRzO1xuXG4gIGNvbnN0IGNvbnRleHQgPSB7c3RhdGUsIGV2ZW50fTtcbiAgbGV0IGNoYW5nZWQgPSBkaXNwYXRjaE1vdmVFdmVudHMoY29udGV4dCwgJ2xlYXZlJywgcHJldmlvdXMsIGVsZW1lbnRzKTtcbiAgcmV0dXJuIGRpc3BhdGNoTW92ZUV2ZW50cyhjb250ZXh0LCAnZW50ZXInLCBlbGVtZW50cywgcHJldmlvdXMpIHx8IGNoYW5nZWQ7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZUV2ZW50cyh7c3RhdGUsIGV2ZW50fSwgaG9vaywgZWxlbWVudHMsIGNoZWNrRWxlbWVudHMpIHtcbiAgbGV0IGNoYW5nZWQ7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgIGlmIChjaGVja0VsZW1lbnRzLmluZGV4T2YoZWxlbWVudCkgPCAwKSB7XG4gICAgICBjaGFuZ2VkID0gZGlzcGF0Y2hFdmVudChlbGVtZW50Lm9wdGlvbnNbaG9va10gfHwgc3RhdGUubGlzdGVuZXJzW2hvb2tdLCBlbGVtZW50LCBldmVudCkgfHwgY2hhbmdlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrRXZlbnRzKHN0YXRlLCBldmVudCwgb3B0aW9ucykge1xuICBjb25zdCBsaXN0ZW5lcnMgPSBzdGF0ZS5saXN0ZW5lcnM7XG4gIGNvbnN0IGVsZW1lbnRzID0gZ2V0RWxlbWVudHMoc3RhdGUudmlzaWJsZUVsZW1lbnRzLCBldmVudCwgb3B0aW9ucy5pbnRlcmFjdGlvbik7XG4gIGxldCBjaGFuZ2VkO1xuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICBjaGFuZ2VkID0gZGlzcGF0Y2hFdmVudChlbGVtZW50Lm9wdGlvbnMuY2xpY2sgfHwgbGlzdGVuZXJzLmNsaWNrLCBlbGVtZW50LCBldmVudCkgfHwgY2hhbmdlZDtcbiAgfVxuICByZXR1cm4gY2hhbmdlZDtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChoYW5kbGVyLCBlbGVtZW50LCBldmVudCkge1xuICByZXR1cm4gY2FsbGJhY2soaGFuZGxlciwgW2VsZW1lbnQuJGNvbnRleHQsIGV2ZW50XSkgPT09IHRydWU7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoXCJjaGFydC5qc1wiKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvb3B0aW9ucycpLkFubm90YXRpb25QbHVnaW5PcHRpb25zIH0gQW5ub3RhdGlvblBsdWdpbk9wdGlvbnNcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9lbGVtZW50JykuQW5ub3RhdGlvbkVsZW1lbnQgfSBBbm5vdGF0aW9uRWxlbWVudFxuICovXG5cbmNvbnN0IGVsZW1lbnRIb29rcyA9IFsnYWZ0ZXJEcmF3JywgJ2JlZm9yZURyYXcnXTtcblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0Fubm90YXRpb25QbHVnaW5PcHRpb25zfSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUhvb2tzKGNoYXJ0LCBzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB2aXNpYmxlRWxlbWVudHMgPSBzdGF0ZS52aXNpYmxlRWxlbWVudHM7XG4gIHN0YXRlLmhvb2tlZCA9IGxvYWRIb29rcyhvcHRpb25zLCBlbGVtZW50SG9va3MsIHN0YXRlLmhvb2tzKTtcblxuICBpZiAoIXN0YXRlLmhvb2tlZCkge1xuICAgIHZpc2libGVFbGVtZW50cy5mb3JFYWNoKHNjb3BlID0+IHtcbiAgICAgIGlmICghc3RhdGUuaG9va2VkKSB7XG4gICAgICAgIGVsZW1lbnRIb29rcy5mb3JFYWNoKGhvb2sgPT4ge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHNjb3BlLm9wdGlvbnNbaG9va10pKSB7XG4gICAgICAgICAgICBzdGF0ZS5ob29rZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7QW5ub3RhdGlvbkVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUhvb2soc3RhdGUsIGVsZW1lbnQsIGhvb2spIHtcbiAgaWYgKHN0YXRlLmhvb2tlZCkge1xuICAgIGNvbnN0IGNhbGxiYWNrSG9vayA9IGVsZW1lbnQub3B0aW9uc1tob29rXSB8fCBzdGF0ZS5ob29rc1tob29rXTtcbiAgICByZXR1cm4gY2FsbGJhY2soY2FsbGJhY2tIb29rLCBbZWxlbWVudC4kY29udGV4dF0pO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoXCJjaGFydC5qc1wiKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydChcImNoYXJ0LmpzXCIpLlNjYWxlIH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9vcHRpb25zJykuQ29yZUFubm90YXRpb25PcHRpb25zIH0gQ29yZUFubm90YXRpb25PcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7Q29yZUFubm90YXRpb25PcHRpb25zW119IGFubm90YXRpb25zXG4gKi9cbmZ1bmN0aW9uIGFkanVzdFNjYWxlUmFuZ2UoY2hhcnQsIHNjYWxlLCBhbm5vdGF0aW9ucykge1xuICBjb25zdCByYW5nZSA9IGdldFNjYWxlTGltaXRzKGNoYXJ0LnNjYWxlcywgc2NhbGUsIGFubm90YXRpb25zKTtcbiAgbGV0IGNoYW5nZWQgPSBjaGFuZ2VTY2FsZUxpbWl0KHNjYWxlLCByYW5nZSwgJ21pbicsICdzdWdnZXN0ZWRNaW4nKTtcbiAgY2hhbmdlZCA9IGNoYW5nZVNjYWxlTGltaXQoc2NhbGUsIHJhbmdlLCAnbWF4JywgJ3N1Z2dlc3RlZE1heCcpIHx8IGNoYW5nZWQ7XG4gIGlmIChjaGFuZ2VkICYmIGlzRnVuY3Rpb24oc2NhbGUuaGFuZGxlVGlja1JhbmdlT3B0aW9ucykpIHtcbiAgICBzY2FsZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvcmVBbm5vdGF0aW9uT3B0aW9uc1tdfSBhbm5vdGF0aW9uc1xuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IFNjYWxlIH19IHNjYWxlc1xuICovXG5mdW5jdGlvbiB2ZXJpZnlTY2FsZU9wdGlvbnMoYW5ub3RhdGlvbnMsIHNjYWxlcykge1xuICBmb3IgKGNvbnN0IGFubm90YXRpb24gb2YgYW5ub3RhdGlvbnMpIHtcbiAgICB2ZXJpZnlTY2FsZUlEcyhhbm5vdGF0aW9uLCBzY2FsZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVNjYWxlTGltaXQoc2NhbGUsIHJhbmdlLCBsaW1pdCwgc3VnZ2VzdGVkTGltaXQpIHtcbiAgaWYgKGlzRmluaXRlKHJhbmdlW2xpbWl0XSkgJiYgIXNjYWxlTGltaXREZWZpbmVkKHNjYWxlLm9wdGlvbnMsIGxpbWl0LCBzdWdnZXN0ZWRMaW1pdCkpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gc2NhbGVbbGltaXRdICE9PSByYW5nZVtsaW1pdF07XG4gICAgc2NhbGVbbGltaXRdID0gcmFuZ2VbbGltaXRdO1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYWxlTGltaXREZWZpbmVkKHNjYWxlT3B0aW9ucywgbGltaXQsIHN1Z2dlc3RlZExpbWl0KSB7XG4gIHJldHVybiBkZWZpbmVkKHNjYWxlT3B0aW9uc1tsaW1pdF0pIHx8IGRlZmluZWQoc2NhbGVPcHRpb25zW3N1Z2dlc3RlZExpbWl0XSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVNjYWxlSURzKGFubm90YXRpb24sIHNjYWxlcykge1xuICBmb3IgKGNvbnN0IGtleSBvZiBbJ3NjYWxlSUQnLCAneFNjYWxlSUQnLCAneVNjYWxlSUQnXSkge1xuICAgIGNvbnN0IHNjYWxlSUQgPSByZXRyaWV2ZVNjYWxlSUQoc2NhbGVzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAgIGlmIChzY2FsZUlEICYmICFzY2FsZXNbc2NhbGVJRF0gJiYgdmVyaWZ5UHJvcGVydGllcyhhbm5vdGF0aW9uLCBrZXkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE5vIHNjYWxlIGZvdW5kIHdpdGggaWQgJyR7c2NhbGVJRH0nIGZvciBhbm5vdGF0aW9uICcke2Fubm90YXRpb24uaWR9J2ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlQcm9wZXJ0aWVzKGFubm90YXRpb24sIGtleSkge1xuICBpZiAoa2V5ID09PSAnc2NhbGVJRCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBheGlzID0ga2V5LmNoYXJBdCgwKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIFsnTWluJywgJ01heCcsICdWYWx1ZSddKSB7XG4gICAgaWYgKGRlZmluZWQoYW5ub3RhdGlvbltheGlzICsgcHJvcF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZUxpbWl0cyhzY2FsZXMsIHNjYWxlLCBhbm5vdGF0aW9ucykge1xuICBjb25zdCBheGlzID0gc2NhbGUuYXhpcztcbiAgY29uc3Qgc2NhbGVJRCA9IHNjYWxlLmlkO1xuICBjb25zdCBzY2FsZUlET3B0aW9uID0gYXhpcyArICdTY2FsZUlEJztcbiAgY29uc3QgbGltaXRzID0ge1xuICAgIG1pbjogdmFsdWVPckRlZmF1bHQoc2NhbGUubWluLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLFxuICAgIG1heDogdmFsdWVPckRlZmF1bHQoc2NhbGUubWF4LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gIH07XG4gIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBhbm5vdGF0aW9ucykge1xuICAgIGlmIChhbm5vdGF0aW9uLnNjYWxlSUQgPT09IHNjYWxlSUQpIHtcbiAgICAgIHVwZGF0ZUxpbWl0cyhhbm5vdGF0aW9uLCBzY2FsZSwgWyd2YWx1ZScsICdlbmRWYWx1ZSddLCBsaW1pdHMpO1xuICAgIH0gZWxzZSBpZiAocmV0cmlldmVTY2FsZUlEKHNjYWxlcywgYW5ub3RhdGlvbiwgc2NhbGVJRE9wdGlvbikgPT09IHNjYWxlSUQpIHtcbiAgICAgIHVwZGF0ZUxpbWl0cyhhbm5vdGF0aW9uLCBzY2FsZSwgW2F4aXMgKyAnTWluJywgYXhpcyArICdNYXgnLCBheGlzICsgJ1ZhbHVlJ10sIGxpbWl0cyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW1pdHM7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhhbm5vdGF0aW9uLCBzY2FsZSwgcHJvcHMsIGxpbWl0cykge1xuICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICBjb25zdCByYXcgPSBhbm5vdGF0aW9uW3Byb3BdO1xuICAgIGlmIChkZWZpbmVkKHJhdykpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc2NhbGUucGFyc2UocmF3KTtcbiAgICAgIGxpbWl0cy5taW4gPSBNYXRoLm1pbihsaW1pdHMubWluLCB2YWx1ZSk7XG4gICAgICBsaW1pdHMubWF4ID0gTWF0aC5tYXgobGltaXRzLm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBCb3hBbm5vdGF0aW9uIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHJvdGF0ZWQoe3g6IG1vdXNlWCwgeTogbW91c2VZfSwgdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSwgdG9SYWRpYW5zKC10aGlzLm9wdGlvbnMucm90YXRpb24pKTtcbiAgICByZXR1cm4gaW5Cb3hSYW5nZSh7eCwgeX0sIHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAneDInLCAneTInXSwgdXNlRmluYWxQb3NpdGlvbiksIGF4aXMsIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRDZW50ZXJQb2ludCh0aGlzLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB0cmFuc2xhdGUoY3R4LCB0aGlzLmdldENlbnRlclBvaW50KCksIHRoaXMub3B0aW9ucy5yb3RhdGlvbik7XG4gICAgZHJhd0JveChjdHgsIHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGdldCBsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cyAmJiB0aGlzLmVsZW1lbnRzWzBdO1xuICB9XG5cbiAgcmVzb2x2ZUVsZW1lbnRQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlc29sdmVCb3hBbmRMYWJlbFByb3BlcnRpZXMoY2hhcnQsIG9wdGlvbnMpO1xuICB9XG59XG5cbkJveEFubm90YXRpb24uaWQgPSAnYm94QW5ub3RhdGlvbic7XG5cbkJveEFubm90YXRpb24uZGVmYXVsdHMgPSB7XG4gIGFkanVzdFNjYWxlUmFuZ2U6IHRydWUsXG4gIGJhY2tncm91bmRTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgYm9yZGVyV2lkdGg6IDEsXG4gIGRpc3BsYXk6IHRydWUsXG4gIGluaXQ6IHVuZGVmaW5lZCxcbiAgaGl0VG9sZXJhbmNlOiAwLFxuICBsYWJlbDoge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBjYWxsb3V0OiB7XG4gICAgICBkaXNwbGF5OiBmYWxzZVxuICAgIH0sXG4gICAgY29sb3I6ICdibGFjaycsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBkcmF3VGltZTogdW5kZWZpbmVkLFxuICAgIGZvbnQ6IHtcbiAgICAgIGZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgbGluZUhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgICAgIHdlaWdodDogJ2JvbGQnXG4gICAgfSxcbiAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBoaXRUb2xlcmFuY2U6IHVuZGVmaW5lZCxcbiAgICBvcGFjaXR5OiB1bmRlZmluZWQsXG4gICAgcGFkZGluZzogNixcbiAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgcm90YXRpb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gICAgdGV4dFN0cm9rZUNvbG9yOiB1bmRlZmluZWQsXG4gICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgeEFkanVzdDogMCxcbiAgICB5QWRqdXN0OiAwLFxuICAgIHo6IHVuZGVmaW5lZFxuICB9LFxuICByb3RhdGlvbjogMCxcbiAgc2hhZG93Qmx1cjogMCxcbiAgc2hhZG93T2Zmc2V0WDogMCxcbiAgc2hhZG93T2Zmc2V0WTogMCxcbiAgeE1heDogdW5kZWZpbmVkLFxuICB4TWluOiB1bmRlZmluZWQsXG4gIHhTY2FsZUlEOiB1bmRlZmluZWQsXG4gIHlNYXg6IHVuZGVmaW5lZCxcbiAgeU1pbjogdW5kZWZpbmVkLFxuICB5U2NhbGVJRDogdW5kZWZpbmVkLFxuICB6OiAwXG59O1xuXG5Cb3hBbm5vdGF0aW9uLmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJvcmRlckNvbG9yOiAnY29sb3InLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICdjb2xvcidcbn07XG5cbkJveEFubm90YXRpb24uZGVzY3JpcHRvcnMgPSB7XG4gIGxhYmVsOiB7XG4gICAgX2ZhbGxiYWNrOiB0cnVlXG4gIH1cbn07XG5cbmNsYXNzIERvdWdobnV0TGFiZWxBbm5vdGF0aW9uIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpbkxhYmVsUmFuZ2UoXG4gICAgICB7eDogbW91c2VYLCB5OiBtb3VzZVl9LFxuICAgICAge3JlY3Q6IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAneDInLCAneTInXSwgdXNlRmluYWxQb3NpdGlvbiksIGNlbnRlcjogdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKX0sXG4gICAgICBheGlzLFxuICAgICAge3JvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLCBib3JkZXJXaWR0aDogMCwgaGl0VG9sZXJhbmNlOiB0aGlzLm9wdGlvbnMuaGl0VG9sZXJhbmNlfVxuICAgICk7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRDZW50ZXJQb2ludCh0aGlzLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSB8fCAhb3B0aW9ucy5jb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYXdCYWNrZ3JvdW5kKGN0eCwgdGhpcyk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB0cmFuc2xhdGUoY3R4LCB0aGlzLmdldENlbnRlclBvaW50KCksIHRoaXMucm90YXRpb24pO1xuICAgIGRyYXdMYWJlbChjdHgsIHRoaXMsIG9wdGlvbnMsIHRoaXMuX2ZpdFJhdGlvKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgcmVzb2x2ZUVsZW1lbnRQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWV0YSA9IGdldERhdGFzZXRNZXRhKGNoYXJ0LCBvcHRpb25zKTtcbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qge2NvbnRyb2xsZXJNZXRhLCBwb2ludCwgcmFkaXVzfSA9IGdldENvbnRyb2xsZXJNZXRhKGNoYXJ0LCBvcHRpb25zLCBtZXRhKTtcbiAgICBsZXQgbGFiZWxTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShjaGFydC5jdHgsIG9wdGlvbnMpO1xuICAgIGNvbnN0IF9maXRSYXRpbyA9IGdldEZpdFJhdGlvKGxhYmVsU2l6ZSwgcmFkaXVzKTtcbiAgICBpZiAoc2hvdWxkRml0KG9wdGlvbnMsIF9maXRSYXRpbykpIHtcbiAgICAgIGxhYmVsU2l6ZSA9IHt3aWR0aDogbGFiZWxTaXplLndpZHRoICogX2ZpdFJhdGlvLCBoZWlnaHQ6IGxhYmVsU2l6ZS5oZWlnaHQgKiBfZml0UmF0aW99O1xuICAgIH1cbiAgICBjb25zdCB7cG9zaXRpb24sIHhBZGp1c3QsIHlBZGp1c3R9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib3hTaXplID0gbWVhc3VyZUxhYmVsUmVjdGFuZ2xlKHBvaW50LCBsYWJlbFNpemUsIHtib3JkZXJXaWR0aDogMCwgcG9zaXRpb24sIHhBZGp1c3QsIHlBZGp1c3R9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdFByb3BlcnRpZXM6IGluaXRBbmltYXRpb25Qcm9wZXJ0aWVzKGNoYXJ0LCBib3hTaXplLCBvcHRpb25zKSxcbiAgICAgIC4uLmJveFNpemUsXG4gICAgICAuLi5jb250cm9sbGVyTWV0YSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgICAgX2ZpdFJhdGlvXG4gICAgfTtcbiAgfVxufVxuXG5Eb3VnaG51dExhYmVsQW5ub3RhdGlvbi5pZCA9ICdkb3VnaG51dExhYmVsQW5ub3RhdGlvbic7XG5cbkRvdWdobnV0TGFiZWxBbm5vdGF0aW9uLmRlZmF1bHRzID0ge1xuICBhdXRvRml0OiB0cnVlLFxuICBhdXRvSGlkZTogdHJ1ZSxcbiAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICBiYWNrZ3JvdW5kU2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gIGJvcmRlckNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGNvbG9yOiAnYmxhY2snLFxuICBjb250ZW50OiBudWxsLFxuICBkaXNwbGF5OiB0cnVlLFxuICBmb250OiB7XG4gICAgZmFtaWx5OiB1bmRlZmluZWQsXG4gICAgbGluZUhlaWdodDogdW5kZWZpbmVkLFxuICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgIHdlaWdodDogdW5kZWZpbmVkXG4gIH0sXG4gIGhlaWdodDogdW5kZWZpbmVkLFxuICBoaXRUb2xlcmFuY2U6IDAsXG4gIGluaXQ6IHVuZGVmaW5lZCxcbiAgb3BhY2l0eTogdW5kZWZpbmVkLFxuICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gIHJvdGF0aW9uOiAwLFxuICBzaGFkb3dCbHVyOiAwLFxuICBzaGFkb3dPZmZzZXRYOiAwLFxuICBzaGFkb3dPZmZzZXRZOiAwLFxuICBzcGFjaW5nOiAxLFxuICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICB0ZXh0U3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICB3aWR0aDogdW5kZWZpbmVkLFxuICB4QWRqdXN0OiAwLFxuICB5QWRqdXN0OiAwXG59O1xuXG5Eb3VnaG51dExhYmVsQW5ub3RhdGlvbi5kZWZhdWx0Um91dGVzID0ge1xufTtcblxuZnVuY3Rpb24gZ2V0RGF0YXNldE1ldGEoY2hhcnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB2YWx1ZS5jb250cm9sbGVyO1xuICAgIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRG91Z2hudXRDb250cm9sbGVyICYmXG4gICAgICBpc0NvbnRyb2xsZXJWaXNpYmxlKGNoYXJ0LCBvcHRpb25zLCB2YWx1ZS5kYXRhKSAmJlxuICAgICAgKCFyZXN1bHQgfHwgY29udHJvbGxlci5pbm5lclJhZGl1cyA8IHJlc3VsdC5jb250cm9sbGVyLmlubmVyUmFkaXVzKSAmJlxuICAgICAgY29udHJvbGxlci5vcHRpb25zLmNpcmN1bWZlcmVuY2UgPj0gOTApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gaXNDb250cm9sbGVyVmlzaWJsZShjaGFydCwgb3B0aW9ucywgZWxlbWVudHMpIHtcbiAgaWYgKCFvcHRpb25zLmF1dG9IaWRlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZWxlbWVudHNbaV0uaGlkZGVuICYmIGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbGxlck1ldGEoe2NoYXJ0QXJlYX0sIG9wdGlvbnMsIG1ldGEpIHtcbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBjaGFydEFyZWE7XG4gIGNvbnN0IHtpbm5lclJhZGl1cywgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBtZXRhLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHggPSAobGVmdCArIHJpZ2h0KSAvIDIgKyBvZmZzZXRYO1xuICBjb25zdCB5ID0gKHRvcCArIGJvdHRvbSkgLyAyICsgb2Zmc2V0WTtcbiAgY29uc3Qgc3F1YXJlID0ge1xuICAgIGxlZnQ6IE1hdGgubWF4KHggLSBpbm5lclJhZGl1cywgbGVmdCksXG4gICAgcmlnaHQ6IE1hdGgubWluKHggKyBpbm5lclJhZGl1cywgcmlnaHQpLFxuICAgIHRvcDogTWF0aC5tYXgoeSAtIGlubmVyUmFkaXVzLCB0b3ApLFxuICAgIGJvdHRvbTogTWF0aC5taW4oeSArIGlubmVyUmFkaXVzLCBib3R0b20pXG4gIH07XG4gIGNvbnN0IHBvaW50ID0ge1xuICAgIHg6IChzcXVhcmUubGVmdCArIHNxdWFyZS5yaWdodCkgLyAyLFxuICAgIHk6IChzcXVhcmUudG9wICsgc3F1YXJlLmJvdHRvbSkgLyAyXG4gIH07XG4gIGNvbnN0IHNwYWNlID0gb3B0aW9ucy5zcGFjaW5nICsgb3B0aW9ucy5ib3JkZXJXaWR0aCAvIDI7XG4gIGNvbnN0IF9yYWRpdXMgPSBpbm5lclJhZGl1cyAtIHNwYWNlO1xuICBjb25zdCBfY291bnRlcmNsb2Nrd2lzZSA9IHBvaW50LnkgPiB5O1xuICBjb25zdCBzaWRlID0gX2NvdW50ZXJjbG9ja3dpc2UgPyB0b3AgKyBzcGFjZSA6IGJvdHRvbSAtIHNwYWNlO1xuICBjb25zdCBhbmdsZXMgPSBnZXRBbmdsZXMoc2lkZSwgeCwgeSwgX3JhZGl1cyk7XG4gIGNvbnN0IGNvbnRyb2xsZXJNZXRhID0ge1xuICAgIF9jZW50ZXJYOiB4LFxuICAgIF9jZW50ZXJZOiB5LFxuICAgIF9yYWRpdXMsXG4gICAgX2NvdW50ZXJjbG9ja3dpc2UsXG4gICAgLi4uYW5nbGVzXG4gIH07XG4gIHJldHVybiB7XG4gICAgY29udHJvbGxlck1ldGEsXG4gICAgcG9pbnQsXG4gICAgcmFkaXVzOiBNYXRoLm1pbihpbm5lclJhZGl1cywgTWF0aC5taW4oc3F1YXJlLnJpZ2h0IC0gc3F1YXJlLmxlZnQsIHNxdWFyZS5ib3R0b20gLSBzcXVhcmUudG9wKSAvIDIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZpdFJhdGlvKHt3aWR0aCwgaGVpZ2h0fSwgcmFkaXVzKSB7XG4gIGNvbnN0IGh5cG8gPSBNYXRoLnNxcnQoTWF0aC5wb3cod2lkdGgsIDIpICsgTWF0aC5wb3coaGVpZ2h0LCAyKSk7XG4gIHJldHVybiAocmFkaXVzICogMikgLyBoeXBvO1xufVxuXG5mdW5jdGlvbiBnZXRBbmdsZXMoeSwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XG4gIGNvbnN0IHlrMiA9IE1hdGgucG93KGNlbnRlclkgLSB5LCAyKTtcbiAgY29uc3QgcjIgPSBNYXRoLnBvdyhyYWRpdXMsIDIpO1xuICBjb25zdCBiID0gY2VudGVyWCAqIC0yO1xuICBjb25zdCBjID0gTWF0aC5wb3coY2VudGVyWCwgMikgKyB5azIgLSByMjtcbiAgY29uc3QgZGVsdGEgPSBNYXRoLnBvdyhiLCAyKSAtICg0ICogYyk7XG4gIGlmIChkZWx0YSA8PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9zdGFydEFuZ2xlOiAwLFxuICAgICAgX2VuZEFuZ2xlOiBUQVVcbiAgICB9O1xuICB9XG4gIGNvbnN0IHN0YXJ0ID0gKC1iIC0gTWF0aC5zcXJ0KGRlbHRhKSkgLyAyO1xuICBjb25zdCBlbmQgPSAoLWIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvIDI7XG4gIHJldHVybiB7XG4gICAgX3N0YXJ0QW5nbGU6IGdldEFuZ2xlRnJvbVBvaW50KHt4OiBjZW50ZXJYLCB5OiBjZW50ZXJZfSwge3g6IHN0YXJ0LCB5fSkuYW5nbGUsXG4gICAgX2VuZEFuZ2xlOiBnZXRBbmdsZUZyb21Qb2ludCh7eDogY2VudGVyWCwgeTogY2VudGVyWX0sIHt4OiBlbmQsIHl9KS5hbmdsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChjdHgsIGVsZW1lbnQpIHtcbiAgY29uc3Qge19jZW50ZXJYLCBfY2VudGVyWSwgX3JhZGl1cywgX3N0YXJ0QW5nbGUsIF9lbmRBbmdsZSwgX2NvdW50ZXJjbG9ja3dpc2UsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY3R4LnNhdmUoKTtcbiAgY29uc3Qgc3Ryb2tlID0gc2V0Qm9yZGVyU3R5bGUoY3R4LCBvcHRpb25zKTtcbiAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoX2NlbnRlclgsIF9jZW50ZXJZLCBfcmFkaXVzLCBfc3RhcnRBbmdsZSwgX2VuZEFuZ2xlLCBfY291bnRlcmNsb2Nrd2lzZSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbiAgaWYgKHN0cm9rZSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuXG5jbGFzcyBMYWJlbEFubm90YXRpb24gZXh0ZW5kcyBFbGVtZW50IHtcblxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluTGFiZWxSYW5nZShcbiAgICAgIHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0sXG4gICAgICB7cmVjdDogdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICd4MicsICd5MiddLCB1c2VGaW5hbFBvc2l0aW9uKSwgY2VudGVyOiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pfSxcbiAgICAgIGF4aXMsXG4gICAgICB7cm90YXRpb246IHRoaXMucm90YXRpb24sIGJvcmRlcldpZHRoOiB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgsIGhpdFRvbGVyYW5jZTogdGhpcy5vcHRpb25zLmhpdFRvbGVyYW5jZX1cbiAgICApO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBnZXRFbGVtZW50Q2VudGVyUG9pbnQodGhpcywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmlzaWJsZSA9ICFkZWZpbmVkKHRoaXMuX3Zpc2libGUpIHx8IHRoaXMuX3Zpc2libGU7XG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkgfHwgIW9wdGlvbnMuY29udGVudCB8fCAhdmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIHRyYW5zbGF0ZShjdHgsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgdGhpcy5yb3RhdGlvbik7XG4gICAgZHJhd0NhbGxvdXQoY3R4LCB0aGlzKTtcbiAgICBkcmF3Qm94KGN0eCwgdGhpcywgb3B0aW9ucyk7XG4gICAgZHJhd0xhYmVsKGN0eCwgZ2V0TGFiZWxTaXplKHRoaXMpLCBvcHRpb25zKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgcmVzb2x2ZUVsZW1lbnRQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKSB7XG4gICAgbGV0IHBvaW50O1xuICAgIGlmICghaXNCb3VuZFRvUG9pbnQob3B0aW9ucykpIHtcbiAgICAgIGNvbnN0IHtjZW50ZXJYLCBjZW50ZXJZfSA9IHJlc29sdmVCb3hQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKTtcbiAgICAgIHBvaW50ID0ge3g6IGNlbnRlclgsIHk6IGNlbnRlcll9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludCA9IGdldENoYXJ0UG9pbnQoY2hhcnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgY29uc3QgbGFiZWxTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShjaGFydC5jdHgsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJveFNpemUgPSBtZWFzdXJlTGFiZWxSZWN0YW5nbGUocG9pbnQsIGxhYmVsU2l6ZSwgb3B0aW9ucywgcGFkZGluZyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRQcm9wZXJ0aWVzOiBpbml0QW5pbWF0aW9uUHJvcGVydGllcyhjaGFydCwgYm94U2l6ZSwgb3B0aW9ucyksXG4gICAgICBwb2ludFg6IHBvaW50LngsXG4gICAgICBwb2ludFk6IHBvaW50LnksXG4gICAgICAuLi5ib3hTaXplLFxuICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb25cbiAgICB9O1xuICB9XG59XG5cbkxhYmVsQW5ub3RhdGlvbi5pZCA9ICdsYWJlbEFubm90YXRpb24nO1xuXG5MYWJlbEFubm90YXRpb24uZGVmYXVsdHMgPSB7XG4gIGFkanVzdFNjYWxlUmFuZ2U6IHRydWUsXG4gIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgYmFja2dyb3VuZFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlclNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuICBib3JkZXJXaWR0aDogMCxcbiAgY2FsbG91dDoge1xuICAgIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gICAgYm9yZGVyQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBtYXJnaW46IDUsXG4gICAgcG9zaXRpb246ICdhdXRvJyxcbiAgICBzaWRlOiA1LFxuICAgIHN0YXJ0OiAnNTAlJyxcbiAgfSxcbiAgY29sb3I6ICdibGFjaycsXG4gIGNvbnRlbnQ6IG51bGwsXG4gIGRpc3BsYXk6IHRydWUsXG4gIGZvbnQ6IHtcbiAgICBmYW1pbHk6IHVuZGVmaW5lZCxcbiAgICBsaW5lSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgIHN0eWxlOiB1bmRlZmluZWQsXG4gICAgd2VpZ2h0OiB1bmRlZmluZWRcbiAgfSxcbiAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gIGhpdFRvbGVyYW5jZTogMCxcbiAgaW5pdDogdW5kZWZpbmVkLFxuICBvcGFjaXR5OiB1bmRlZmluZWQsXG4gIHBhZGRpbmc6IDYsXG4gIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgcm90YXRpb246IDAsXG4gIHNoYWRvd0JsdXI6IDAsXG4gIHNoYWRvd09mZnNldFg6IDAsXG4gIHNoYWRvd09mZnNldFk6IDAsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHRleHRTdHJva2VDb2xvcjogdW5kZWZpbmVkLFxuICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIHhBZGp1c3Q6IDAsXG4gIHhNYXg6IHVuZGVmaW5lZCxcbiAgeE1pbjogdW5kZWZpbmVkLFxuICB4U2NhbGVJRDogdW5kZWZpbmVkLFxuICB4VmFsdWU6IHVuZGVmaW5lZCxcbiAgeUFkanVzdDogMCxcbiAgeU1heDogdW5kZWZpbmVkLFxuICB5TWluOiB1bmRlZmluZWQsXG4gIHlTY2FsZUlEOiB1bmRlZmluZWQsXG4gIHlWYWx1ZTogdW5kZWZpbmVkLFxuICB6OiAwXG59O1xuXG5MYWJlbEFubm90YXRpb24uZGVmYXVsdFJvdXRlcyA9IHtcbiAgYm9yZGVyQ29sb3I6ICdjb2xvcidcbn07XG5cbmZ1bmN0aW9uIGdldExhYmVsU2l6ZSh7eCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9uc30pIHtcbiAgY29uc3QgaEJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aCAvIDI7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgcGFkZGluZy5sZWZ0ICsgaEJvcmRlcldpZHRoLFxuICAgIHk6IHkgKyBwYWRkaW5nLnRvcCArIGhCb3JkZXJXaWR0aCxcbiAgICB3aWR0aDogd2lkdGggLSBwYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0IC0gb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCAtIHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20gLSBvcHRpb25zLmJvcmRlcldpZHRoXG4gIH07XG59XG5cbmNvbnN0IHBvaW50SW5MaW5lID0gKHAxLCBwMiwgdCkgPT4gKHt4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KX0pO1xuY29uc3QgaW50ZXJwb2xhdGVYID0gKHksIHAxLCBwMikgPT4gcG9pbnRJbkxpbmUocDEsIHAyLCBNYXRoLmFicygoeSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSkpLng7XG5jb25zdCBpbnRlcnBvbGF0ZVkgPSAoeCwgcDEsIHAyKSA9PiBwb2ludEluTGluZShwMSwgcDIsIE1hdGguYWJzKCh4IC0gcDEueCkgLyAocDIueCAtIHAxLngpKSkueTtcbmNvbnN0IHNxciA9IHYgPT4gdiAqIHY7XG5jb25zdCByYW5nZUxpbWl0ID0gKG1vdXNlWCwgbW91c2VZLCB7eCwgeSwgeDIsIHkyfSwgYXhpcykgPT4gYXhpcyA9PT0gJ3knID8ge3N0YXJ0OiBNYXRoLm1pbih5LCB5MiksIGVuZDogTWF0aC5tYXgoeSwgeTIpLCB2YWx1ZTogbW91c2VZfSA6IHtzdGFydDogTWF0aC5taW4oeCwgeDIpLCBlbmQ6IE1hdGgubWF4KHgsIHgyKSwgdmFsdWU6IG1vdXNlWH07XG4vLyBodHRwOi8vd3d3LmluZGVwZW5kZW50LXNvZnR3YXJlLmNvbS9kZXRlcm1pbmluZy1jb29yZGluYXRlcy1vbi1hLWh0bWwtY2FudmFzLWJlemllci1jdXJ2ZS5odG1sXG5jb25zdCBjb29yZEluQ3VydmUgPSAoc3RhcnQsIGNwLCBlbmQsIHQpID0+ICgxIC0gdCkgKiAoMSAtIHQpICogc3RhcnQgKyAyICogKDEgLSB0KSAqIHQgKiBjcCArIHQgKiB0ICogZW5kO1xuY29uc3QgcG9pbnRJbkN1cnZlID0gKHN0YXJ0LCBjcCwgZW5kLCB0KSA9PiAoe3g6IGNvb3JkSW5DdXJ2ZShzdGFydC54LCBjcC54LCBlbmQueCwgdCksIHk6IGNvb3JkSW5DdXJ2ZShzdGFydC55LCBjcC55LCBlbmQueSwgdCl9KTtcbmNvbnN0IGNvb3JkQW5nbGVJbkN1cnZlID0gKHN0YXJ0LCBjcCwgZW5kLCB0KSA9PiAyICogKDEgLSB0KSAqIChjcCAtIHN0YXJ0KSArIDIgKiB0ICogKGVuZCAtIGNwKTtcbmNvbnN0IGFuZ2xlSW5DdXJ2ZSA9IChzdGFydCwgY3AsIGVuZCwgdCkgPT4gLU1hdGguYXRhbjIoY29vcmRBbmdsZUluQ3VydmUoc3RhcnQueCwgY3AueCwgZW5kLngsIHQpLCBjb29yZEFuZ2xlSW5DdXJ2ZShzdGFydC55LCBjcC55LCBlbmQueSwgdCkpICsgMC41ICogUEk7XG5cbmNsYXNzIExpbmVBbm5vdGF0aW9uIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IGhpdFNpemUgPSAodGhpcy5vcHRpb25zLmJvcmRlcldpZHRoICsgdGhpcy5vcHRpb25zLmhpdFRvbGVyYW5jZSkgLyAyO1xuICAgIGlmIChheGlzICE9PSAneCcgJiYgYXhpcyAhPT0gJ3knKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHttb3VzZVgsIG1vdXNlWX07XG4gICAgICBjb25zdCB7cGF0aCwgY3R4fSA9IHRoaXM7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBzZXRCb3JkZXJTdHlsZShjdHgsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggKz0gdGhpcy5vcHRpb25zLmhpdFRvbGVyYW5jZTtcbiAgICAgICAgY29uc3Qge2NoYXJ0fSA9IHRoaXMuJGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IG14ID0gbW91c2VYICogY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IG15ID0gbW91c2VZICogY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGN0eC5pc1BvaW50SW5TdHJva2UocGF0aCwgbXgsIG15KSB8fCBpc09uTGFiZWwodGhpcywgcG9pbnQsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgY29uc3QgZXBzaWxvbiA9IHNxcihoaXRTaXplKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3RzKHRoaXMsIHBvaW50LCBlcHNpbG9uLCB1c2VGaW5hbFBvc2l0aW9uKSB8fCBpc09uTGFiZWwodGhpcywgcG9pbnQsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gaW5BeGlzUmFuZ2UodGhpcywge21vdXNlWCwgbW91c2VZfSwgYXhpcywge2hpdFNpemUsIHVzZUZpbmFsUG9zaXRpb259KTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gZ2V0RWxlbWVudENlbnRlclBvaW50KHRoaXMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7eCwgeSwgeDIsIHkyLCBjcCwgb3B0aW9uc30gPSB0aGlzO1xuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoIXNldEJvcmRlclN0eWxlKGN0eCwgb3B0aW9ucykpIHtcbiAgICAgIC8vIG5vIGJvcmRlciB3aWR0aCwgdGhlbiBsaW5lIGlzIG5vdCBkcmF3blxuICAgICAgcmV0dXJuIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHNldFNoYWRvd1N0eWxlKGN0eCwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4LCAyKSArIE1hdGgucG93KHkyIC0geSwgMikpO1xuICAgIGlmIChvcHRpb25zLmN1cnZlICYmIGNwKSB7XG4gICAgICBkcmF3Q3VydmUoY3R4LCB0aGlzLCBjcCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBjb25zdCB7c3RhcnRPcHRzLCBlbmRPcHRzLCBzdGFydEFkanVzdCwgZW5kQWRqdXN0fSA9IGdldEFycm93SGVhZHModGhpcyk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geSwgeDIgLSB4KTtcbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKDAgKyBzdGFydEFkanVzdCwgMCk7XG4gICAgY3R4LmxpbmVUbyhsZW5ndGggLSBlbmRBZGp1c3QsIDApO1xuICAgIGN0eC5zaGFkb3dDb2xvciA9IG9wdGlvbnMuYm9yZGVyU2hhZG93Q29sb3I7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGRyYXdBcnJvd0hlYWQoY3R4LCAwLCBzdGFydEFkanVzdCwgc3RhcnRPcHRzKTtcbiAgICBkcmF3QXJyb3dIZWFkKGN0eCwgbGVuZ3RoLCAtZW5kQWRqdXN0LCBlbmRPcHRzKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgZ2V0IGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzICYmIHRoaXMuZWxlbWVudHNbMF07XG4gIH1cblxuICByZXNvbHZlRWxlbWVudFByb3BlcnRpZXMoY2hhcnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhcmVhID0gcmVzb2x2ZUxpbmVQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKTtcbiAgICBjb25zdCB7eCwgeSwgeDIsIHkyfSA9IGFyZWE7XG4gICAgY29uc3QgaW5zaWRlID0gaXNMaW5lSW5BcmVhKGFyZWEsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGluc2lkZVxuICAgICAgPyBsaW1pdExpbmVUb0FyZWEoe3gsIHl9LCB7eDogeDIsIHk6IHkyfSwgY2hhcnQuY2hhcnRBcmVhKVxuICAgICAgOiB7eCwgeSwgeDIsIHkyLCB3aWR0aDogTWF0aC5hYnMoeDIgLSB4KSwgaGVpZ2h0OiBNYXRoLmFicyh5MiAtIHkpfTtcbiAgICBwcm9wZXJ0aWVzLmNlbnRlclggPSAoeDIgKyB4KSAvIDI7XG4gICAgcHJvcGVydGllcy5jZW50ZXJZID0gKHkyICsgeSkgLyAyO1xuICAgIHByb3BlcnRpZXMuaW5pdFByb3BlcnRpZXMgPSBpbml0QW5pbWF0aW9uUHJvcGVydGllcyhjaGFydCwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuY3VydmUpIHtcbiAgICAgIGNvbnN0IHAxID0ge3g6IHByb3BlcnRpZXMueCwgeTogcHJvcGVydGllcy55fTtcbiAgICAgIGNvbnN0IHAyID0ge3g6IHByb3BlcnRpZXMueDIsIHk6IHByb3BlcnRpZXMueTJ9O1xuICAgICAgcHJvcGVydGllcy5jcCA9IGdldENvbnRyb2xQb2ludChwcm9wZXJ0aWVzLCBvcHRpb25zLCBkaXN0YW5jZUJldHdlZW5Qb2ludHMocDEsIHAyKSk7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsUHJvcGVydGllcyA9IHJlc29sdmVMYWJlbEVsZW1lbnRQcm9wZXJ0aWVzKGNoYXJ0LCBwcm9wZXJ0aWVzLCBvcHRpb25zLmxhYmVsKTtcbiAgICAvLyBhZGRpdG9uYWwgcHJvcCB0byBtYW5hZ2Ugem9vbS9wYW5cbiAgICBsYWJlbFByb3BlcnRpZXMuX3Zpc2libGUgPSBpbnNpZGU7XG5cbiAgICBwcm9wZXJ0aWVzLmVsZW1lbnRzID0gW3tcbiAgICAgIHR5cGU6ICdsYWJlbCcsXG4gICAgICBvcHRpb25TY29wZTogJ2xhYmVsJyxcbiAgICAgIHByb3BlcnRpZXM6IGxhYmVsUHJvcGVydGllcyxcbiAgICAgIGluaXRQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLmluaXRQcm9wZXJ0aWVzXG4gICAgfV07XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbn1cblxuTGluZUFubm90YXRpb24uaWQgPSAnbGluZUFubm90YXRpb24nO1xuXG5jb25zdCBhcnJvd0hlYWRzRGVmYXVsdHMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogdW5kZWZpbmVkLFxuICBiYWNrZ3JvdW5kU2hhZG93Q29sb3I6IHVuZGVmaW5lZCxcbiAgYm9yZGVyQ29sb3I6IHVuZGVmaW5lZCxcbiAgYm9yZGVyRGFzaDogdW5kZWZpbmVkLFxuICBib3JkZXJEYXNoT2Zmc2V0OiB1bmRlZmluZWQsXG4gIGJvcmRlclNoYWRvd0NvbG9yOiB1bmRlZmluZWQsXG4gIGJvcmRlcldpZHRoOiB1bmRlZmluZWQsXG4gIGRpc3BsYXk6IHVuZGVmaW5lZCxcbiAgZmlsbDogdW5kZWZpbmVkLFxuICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgc2hhZG93Qmx1cjogdW5kZWZpbmVkLFxuICBzaGFkb3dPZmZzZXRYOiB1bmRlZmluZWQsXG4gIHNoYWRvd09mZnNldFk6IHVuZGVmaW5lZCxcbiAgd2lkdGg6IHVuZGVmaW5lZFxufTtcblxuTGluZUFubm90YXRpb24uZGVmYXVsdHMgPSB7XG4gIGFkanVzdFNjYWxlUmFuZ2U6IHRydWUsXG4gIGFycm93SGVhZHM6IHtcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGFycm93SGVhZHNEZWZhdWx0cyksXG4gICAgZmlsbDogZmFsc2UsXG4gICAgbGVuZ3RoOiAxMixcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgYXJyb3dIZWFkc0RlZmF1bHRzKSxcbiAgICB3aWR0aDogNlxuICB9LFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVyU2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gIGJvcmRlcldpZHRoOiAyLFxuICBjdXJ2ZTogZmFsc2UsXG4gIGNvbnRyb2xQb2ludDoge1xuICAgIHk6ICctNTAlJ1xuICB9LFxuICBkaXNwbGF5OiB0cnVlLFxuICBlbmRWYWx1ZTogdW5kZWZpbmVkLFxuICBpbml0OiB1bmRlZmluZWQsXG4gIGhpdFRvbGVyYW5jZTogMCxcbiAgbGFiZWw6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIGJhY2tncm91bmRTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICAgIGJvcmRlckNvbG9yOiAnYmxhY2snLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICAgIGJvcmRlclJhZGl1czogNixcbiAgICBib3JkZXJTaGFkb3dDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBjYWxsb3V0OiBPYmplY3QuYXNzaWduKHt9LCBMYWJlbEFubm90YXRpb24uZGVmYXVsdHMuY2FsbG91dCksXG4gICAgY29sb3I6ICcjZmZmJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGRyYXdUaW1lOiB1bmRlZmluZWQsXG4gICAgZm9udDoge1xuICAgICAgZmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICBsaW5lSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgICAgd2VpZ2h0OiAnYm9sZCdcbiAgICB9LFxuICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgIGhpdFRvbGVyYW5jZTogdW5kZWZpbmVkLFxuICAgIG9wYWNpdHk6IHVuZGVmaW5lZCxcbiAgICBwYWRkaW5nOiA2LFxuICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzaGFkb3dCbHVyOiAwLFxuICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgc2hhZG93T2Zmc2V0WTogMCxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgIHRleHRTdHJva2VDb2xvcjogdW5kZWZpbmVkLFxuICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIHhBZGp1c3Q6IDAsXG4gICAgeUFkanVzdDogMCxcbiAgICB6OiB1bmRlZmluZWRcbiAgfSxcbiAgc2NhbGVJRDogdW5kZWZpbmVkLFxuICBzaGFkb3dCbHVyOiAwLFxuICBzaGFkb3dPZmZzZXRYOiAwLFxuICBzaGFkb3dPZmZzZXRZOiAwLFxuICB2YWx1ZTogdW5kZWZpbmVkLFxuICB4TWF4OiB1bmRlZmluZWQsXG4gIHhNaW46IHVuZGVmaW5lZCxcbiAgeFNjYWxlSUQ6IHVuZGVmaW5lZCxcbiAgeU1heDogdW5kZWZpbmVkLFxuICB5TWluOiB1bmRlZmluZWQsXG4gIHlTY2FsZUlEOiB1bmRlZmluZWQsXG4gIHo6IDBcbn07XG5cbkxpbmVBbm5vdGF0aW9uLmRlc2NyaXB0b3JzID0ge1xuICBhcnJvd0hlYWRzOiB7XG4gICAgc3RhcnQ6IHtcbiAgICAgIF9mYWxsYmFjazogdHJ1ZVxuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICBfZmFsbGJhY2s6IHRydWVcbiAgICB9LFxuICAgIF9mYWxsYmFjazogdHJ1ZVxuICB9XG59O1xuXG5MaW5lQW5ub3RhdGlvbi5kZWZhdWx0Um91dGVzID0ge1xuICBib3JkZXJDb2xvcjogJ2NvbG9yJ1xufTtcblxuZnVuY3Rpb24gaW5BeGlzUmFuZ2UoZWxlbWVudCwge21vdXNlWCwgbW91c2VZfSwgYXhpcywge2hpdFNpemUsIHVzZUZpbmFsUG9zaXRpb259KSB7XG4gIGNvbnN0IGxpbWl0ID0gcmFuZ2VMaW1pdChtb3VzZVgsIG1vdXNlWSwgZWxlbWVudC5nZXRQcm9wcyhbJ3gnLCAneScsICd4MicsICd5MiddLCB1c2VGaW5hbFBvc2l0aW9uKSwgYXhpcyk7XG4gIHJldHVybiBpbkxpbWl0KGxpbWl0LCBoaXRTaXplKSB8fCBpc09uTGFiZWwoZWxlbWVudCwge21vdXNlWCwgbW91c2VZfSwgdXNlRmluYWxQb3NpdGlvbiwgYXhpcyk7XG59XG5cbmZ1bmN0aW9uIGlzTGluZUluQXJlYSh7eCwgeSwgeDIsIHkyfSwge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0pIHtcbiAgcmV0dXJuICEoXG4gICAgKHggPCBsZWZ0ICYmIHgyIDwgbGVmdCkgfHxcbiAgICAoeCA+IHJpZ2h0ICYmIHgyID4gcmlnaHQpIHx8XG4gICAgKHkgPCB0b3AgJiYgeTIgPCB0b3ApIHx8XG4gICAgKHkgPiBib3R0b20gJiYgeTIgPiBib3R0b20pXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxpbWl0UG9pbnRUb0FyZWEoe3gsIHl9LCBwMiwge3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdH0pIHtcbiAgaWYgKHggPCBsZWZ0KSB7XG4gICAgeSA9IGludGVycG9sYXRlWShsZWZ0LCB7eCwgeX0sIHAyKTtcbiAgICB4ID0gbGVmdDtcbiAgfVxuICBpZiAoeCA+IHJpZ2h0KSB7XG4gICAgeSA9IGludGVycG9sYXRlWShyaWdodCwge3gsIHl9LCBwMik7XG4gICAgeCA9IHJpZ2h0O1xuICB9XG4gIGlmICh5IDwgdG9wKSB7XG4gICAgeCA9IGludGVycG9sYXRlWCh0b3AsIHt4LCB5fSwgcDIpO1xuICAgIHkgPSB0b3A7XG4gIH1cbiAgaWYgKHkgPiBib3R0b20pIHtcbiAgICB4ID0gaW50ZXJwb2xhdGVYKGJvdHRvbSwge3gsIHl9LCBwMik7XG4gICAgeSA9IGJvdHRvbTtcbiAgfVxuICByZXR1cm4ge3gsIHl9O1xufVxuXG5mdW5jdGlvbiBsaW1pdExpbmVUb0FyZWEocDEsIHAyLCBhcmVhKSB7XG4gIGNvbnN0IHt4LCB5fSA9IGxpbWl0UG9pbnRUb0FyZWEocDEsIHAyLCBhcmVhKTtcbiAgY29uc3Qge3g6IHgyLCB5OiB5Mn0gPSBsaW1pdFBvaW50VG9BcmVhKHAyLCBwMSwgYXJlYSk7XG4gIHJldHVybiB7eCwgeSwgeDIsIHkyLCB3aWR0aDogTWF0aC5hYnMoeDIgLSB4KSwgaGVpZ2h0OiBNYXRoLmFicyh5MiAtIHkpfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhlbGVtZW50LCB7bW91c2VYLCBtb3VzZVl9LCBlcHNpbG9uID0gRVBTSUxPTiwgdXNlRmluYWxQb3NpdGlvbikge1xuICAvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY4NTM5MjYvMjU1MDdcbiAgY29uc3Qge3g6IHgxLCB5OiB5MSwgeDIsIHkyfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWyd4JywgJ3knLCAneDInLCAneTInXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBjb25zdCBsZW5TcSA9IHNxcihkeCkgKyBzcXIoZHkpO1xuICBjb25zdCB0ID0gbGVuU3EgPT09IDAgPyAtMSA6ICgobW91c2VYIC0geDEpICogZHggKyAobW91c2VZIC0geTEpICogZHkpIC8gbGVuU3E7XG5cbiAgbGV0IHh4LCB5eTtcbiAgaWYgKHQgPCAwKSB7XG4gICAgeHggPSB4MTtcbiAgICB5eSA9IHkxO1xuICB9IGVsc2UgaWYgKHQgPiAxKSB7XG4gICAgeHggPSB4MjtcbiAgICB5eSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHh4ID0geDEgKyB0ICogZHg7XG4gICAgeXkgPSB5MSArIHQgKiBkeTtcbiAgfVxuICByZXR1cm4gKHNxcihtb3VzZVggLSB4eCkgKyBzcXIobW91c2VZIC0geXkpKSA8PSBlcHNpbG9uO1xufVxuXG5mdW5jdGlvbiBpc09uTGFiZWwoZWxlbWVudCwge21vdXNlWCwgbW91c2VZfSwgdXNlRmluYWxQb3NpdGlvbiwgYXhpcykge1xuICBjb25zdCBsYWJlbCA9IGVsZW1lbnQubGFiZWw7XG4gIHJldHVybiBsYWJlbC5vcHRpb25zLmRpc3BsYXkgJiYgbGFiZWwuaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgYXhpcywgdXNlRmluYWxQb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVMYWJlbEVsZW1lbnRQcm9wZXJ0aWVzKGNoYXJ0LCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoY2hhcnQuY3R4LCBvcHRpb25zKTtcbiAgY29uc3Qgd2lkdGggPSB0ZXh0U2l6ZS53aWR0aCArIHBhZGRpbmcud2lkdGggKyBib3JkZXJXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gdGV4dFNpemUuaGVpZ2h0ICsgcGFkZGluZy5oZWlnaHQgKyBib3JkZXJXaWR0aDtcbiAgcmV0dXJuIGNhbGN1bGF0ZUxhYmVsUG9zaXRpb24ocHJvcGVydGllcywgb3B0aW9ucywge3dpZHRoLCBoZWlnaHQsIHBhZGRpbmd9LCBjaGFydC5jaGFydEFyZWEpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVBdXRvUm90YXRpb24ocHJvcGVydGllcykge1xuICBjb25zdCB7eCwgeSwgeDIsIHkyfSA9IHByb3BlcnRpZXM7XG4gIGNvbnN0IHJvdGF0aW9uID0gTWF0aC5hdGFuMih5MiAtIHksIHgyIC0geCk7XG4gIC8vIEZsaXAgdGhlIHJvdGF0aW9uIGlmIGl0IGdvZXMgPiBQSS8yIG9yIDwgLVBJLzIsIHNvIGxhYmVsIHN0YXlzIHVwcmlnaHRcbiAgcmV0dXJuIHJvdGF0aW9uID4gUEkgLyAyID8gcm90YXRpb24gLSBQSSA6IHJvdGF0aW9uIDwgUEkgLyAtMiA/IHJvdGF0aW9uICsgUEkgOiByb3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGFiZWxQb3NpdGlvbihwcm9wZXJ0aWVzLCBsYWJlbCwgc2l6ZXMsIGNoYXJ0QXJlYSkge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgcGFkZGluZ30gPSBzaXplcztcbiAgY29uc3Qge3hBZGp1c3QsIHlBZGp1c3R9ID0gbGFiZWw7XG4gIGNvbnN0IHAxID0ge3g6IHByb3BlcnRpZXMueCwgeTogcHJvcGVydGllcy55fTtcbiAgY29uc3QgcDIgPSB7eDogcHJvcGVydGllcy54MiwgeTogcHJvcGVydGllcy55Mn07XG4gIGNvbnN0IHJvdGF0aW9uID0gbGFiZWwucm90YXRpb24gPT09ICdhdXRvJyA/IGNhbGN1bGF0ZUF1dG9Sb3RhdGlvbihwcm9wZXJ0aWVzKSA6IHRvUmFkaWFucyhsYWJlbC5yb3RhdGlvbik7XG4gIGNvbnN0IHNpemUgPSByb3RhdGVkU2l6ZSh3aWR0aCwgaGVpZ2h0LCByb3RhdGlvbik7XG4gIGNvbnN0IHQgPSBjYWxjdWxhdGVUKHByb3BlcnRpZXMsIGxhYmVsLCB7bGFiZWxTaXplOiBzaXplLCBwYWRkaW5nfSwgY2hhcnRBcmVhKTtcbiAgY29uc3QgcHQgPSBwcm9wZXJ0aWVzLmNwID8gcG9pbnRJbkN1cnZlKHAxLCBwcm9wZXJ0aWVzLmNwLCBwMiwgdCkgOiBwb2ludEluTGluZShwMSwgcDIsIHQpO1xuICBjb25zdCB4Q29vcmRpbmF0ZVNpemVzID0ge3NpemU6IHNpemUudywgbWluOiBjaGFydEFyZWEubGVmdCwgbWF4OiBjaGFydEFyZWEucmlnaHQsIHBhZGRpbmc6IHBhZGRpbmcubGVmdH07XG4gIGNvbnN0IHlDb29yZGluYXRlU2l6ZXMgPSB7c2l6ZTogc2l6ZS5oLCBtaW46IGNoYXJ0QXJlYS50b3AsIG1heDogY2hhcnRBcmVhLmJvdHRvbSwgcGFkZGluZzogcGFkZGluZy50b3B9O1xuICBjb25zdCBjZW50ZXJYID0gYWRqdXN0TGFiZWxDb29yZGluYXRlKHB0LngsIHhDb29yZGluYXRlU2l6ZXMpICsgeEFkanVzdDtcbiAgY29uc3QgY2VudGVyWSA9IGFkanVzdExhYmVsQ29vcmRpbmF0ZShwdC55LCB5Q29vcmRpbmF0ZVNpemVzKSArIHlBZGp1c3Q7XG4gIHJldHVybiB7XG4gICAgeDogY2VudGVyWCAtICh3aWR0aCAvIDIpLFxuICAgIHk6IGNlbnRlclkgLSAoaGVpZ2h0IC8gMiksXG4gICAgeDI6IGNlbnRlclggKyAod2lkdGggLyAyKSxcbiAgICB5MjogY2VudGVyWSArIChoZWlnaHQgLyAyKSxcbiAgICBjZW50ZXJYLFxuICAgIGNlbnRlclksXG4gICAgcG9pbnRYOiBwdC54LFxuICAgIHBvaW50WTogcHQueSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgcm90YXRpb246IHRvRGVncmVlcyhyb3RhdGlvbilcbiAgfTtcbn1cblxuZnVuY3Rpb24gcm90YXRlZFNpemUod2lkdGgsIGhlaWdodCwgcm90YXRpb24pIHtcbiAgY29uc3QgY29zID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gIHJldHVybiB7XG4gICAgdzogTWF0aC5hYnMod2lkdGggKiBjb3MpICsgTWF0aC5hYnMoaGVpZ2h0ICogc2luKSxcbiAgICBoOiBNYXRoLmFicyh3aWR0aCAqIHNpbikgKyBNYXRoLmFicyhoZWlnaHQgKiBjb3MpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVQocHJvcGVydGllcywgbGFiZWwsIHNpemVzLCBjaGFydEFyZWEpIHtcbiAgbGV0IHQ7XG4gIGNvbnN0IHNwYWNlID0gc3BhY2VBcm91bmQocHJvcGVydGllcywgY2hhcnRBcmVhKTtcbiAgaWYgKGxhYmVsLnBvc2l0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgdCA9IGNhbGN1bGF0ZVRBZGp1c3Qoe3c6IHByb3BlcnRpZXMueDIgLSBwcm9wZXJ0aWVzLngsIGg6IHByb3BlcnRpZXMueTIgLSBwcm9wZXJ0aWVzLnl9LCBzaXplcywgbGFiZWwsIHNwYWNlKTtcbiAgfSBlbHNlIGlmIChsYWJlbC5wb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICB0ID0gMSAtIGNhbGN1bGF0ZVRBZGp1c3Qoe3c6IHByb3BlcnRpZXMueCAtIHByb3BlcnRpZXMueDIsIGg6IHByb3BlcnRpZXMueSAtIHByb3BlcnRpZXMueTJ9LCBzaXplcywgbGFiZWwsIHNwYWNlKTtcbiAgfSBlbHNlIHtcbiAgICB0ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbigxLCBsYWJlbC5wb3NpdGlvbik7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRBZGp1c3QobGluZVNpemUsIHNpemVzLCBsYWJlbCwgc3BhY2UpIHtcbiAgY29uc3Qge2xhYmVsU2l6ZSwgcGFkZGluZ30gPSBzaXplcztcbiAgY29uc3QgbGluZVcgPSBsaW5lU2l6ZS53ICogc3BhY2UuZHg7XG4gIGNvbnN0IGxpbmVIID0gbGluZVNpemUuaCAqIHNwYWNlLmR5O1xuICBjb25zdCB4ID0gKGxpbmVXID4gMCkgJiYgKChsYWJlbFNpemUudyAvIDIgKyBwYWRkaW5nLmxlZnQgLSBzcGFjZS54KSAvIGxpbmVXKTtcbiAgY29uc3QgeSA9IChsaW5lSCA+IDApICYmICgobGFiZWxTaXplLmggLyAyICsgcGFkZGluZy50b3AgLSBzcGFjZS55KSAvIGxpbmVIKTtcbiAgcmV0dXJuIGNsYW1wKE1hdGgubWF4KHgsIHkpLCAwLCAwLjI1KTtcbn1cblxuZnVuY3Rpb24gc3BhY2VBcm91bmQocHJvcGVydGllcywgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IHt4LCB4MiwgeSwgeTJ9ID0gcHJvcGVydGllcztcbiAgY29uc3QgdCA9IE1hdGgubWluKHksIHkyKSAtIGNoYXJ0QXJlYS50b3A7XG4gIGNvbnN0IGwgPSBNYXRoLm1pbih4LCB4MikgLSBjaGFydEFyZWEubGVmdDtcbiAgY29uc3QgYiA9IGNoYXJ0QXJlYS5ib3R0b20gLSBNYXRoLm1heCh5LCB5Mik7XG4gIGNvbnN0IHIgPSBjaGFydEFyZWEucmlnaHQgLSBNYXRoLm1heCh4LCB4Mik7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5taW4obCwgciksXG4gICAgeTogTWF0aC5taW4odCwgYiksXG4gICAgZHg6IGwgPD0gciA/IDEgOiAtMSxcbiAgICBkeTogdCA8PSBiID8gMSA6IC0xXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkanVzdExhYmVsQ29vcmRpbmF0ZShjb29yZGluYXRlLCBsYWJlbFNpemVzKSB7XG4gIGNvbnN0IHtzaXplLCBtaW4sIG1heCwgcGFkZGluZ30gPSBsYWJlbFNpemVzO1xuICBjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xuICBpZiAoc2l6ZSA+IG1heCAtIG1pbikge1xuICAgIC8vIGlmIGl0IGRvZXMgbm90IGZpdCwgZGlzcGxheSBhcyBtdWNoIGFzIHBvc3NpYmxlXG4gICAgcmV0dXJuIChtYXggKyBtaW4pIC8gMjtcbiAgfVxuICBpZiAobWluID49IChjb29yZGluYXRlIC0gcGFkZGluZyAtIGhhbGZTaXplKSkge1xuICAgIGNvb3JkaW5hdGUgPSBtaW4gKyBwYWRkaW5nICsgaGFsZlNpemU7XG4gIH1cbiAgaWYgKG1heCA8PSAoY29vcmRpbmF0ZSArIHBhZGRpbmcgKyBoYWxmU2l6ZSkpIHtcbiAgICBjb29yZGluYXRlID0gbWF4IC0gcGFkZGluZyAtIGhhbGZTaXplO1xuICB9XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJvd0hlYWRzKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgYXJyb3dTdGFydE9wdHMgPSBvcHRpb25zLmFycm93SGVhZHMgJiYgb3B0aW9ucy5hcnJvd0hlYWRzLnN0YXJ0O1xuICBjb25zdCBhcnJvd0VuZE9wdHMgPSBvcHRpb25zLmFycm93SGVhZHMgJiYgb3B0aW9ucy5hcnJvd0hlYWRzLmVuZDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydE9wdHM6IGFycm93U3RhcnRPcHRzLFxuICAgIGVuZE9wdHM6IGFycm93RW5kT3B0cyxcbiAgICBzdGFydEFkanVzdDogZ2V0TGluZUFkanVzdChsaW5lLCBhcnJvd1N0YXJ0T3B0cyksXG4gICAgZW5kQWRqdXN0OiBnZXRMaW5lQWRqdXN0KGxpbmUsIGFycm93RW5kT3B0cylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TGluZUFkanVzdChsaW5lLCBhcnJvd09wdHMpIHtcbiAgaWYgKCFhcnJvd09wdHMgfHwgIWFycm93T3B0cy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3Qge2xlbmd0aCwgd2lkdGh9ID0gYXJyb3dPcHRzO1xuICBjb25zdCBhZGp1c3QgPSBsaW5lLm9wdGlvbnMuYm9yZGVyV2lkdGggLyAyO1xuICBjb25zdCBwMSA9IHt4OiBsZW5ndGgsIHk6IHdpZHRoICsgYWRqdXN0fTtcbiAgY29uc3QgcDIgPSB7eDogMCwgeTogYWRqdXN0fTtcbiAgcmV0dXJuIE1hdGguYWJzKGludGVycG9sYXRlWCgwLCBwMSwgcDIpKTtcbn1cblxuZnVuY3Rpb24gZHJhd0Fycm93SGVhZChjdHgsIG9mZnNldCwgYWRqdXN0LCBhcnJvd09wdHMpIHtcbiAgaWYgKCFhcnJvd09wdHMgfHwgIWFycm93T3B0cy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtsZW5ndGgsIHdpZHRoLCBmaWxsLCBiYWNrZ3JvdW5kQ29sb3IsIGJvcmRlckNvbG9yfSA9IGFycm93T3B0cztcbiAgY29uc3QgYXJyb3dPZmZzZXRYID0gTWF0aC5hYnMob2Zmc2V0IC0gbGVuZ3RoKSArIGFkanVzdDtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBzZXRTaGFkb3dTdHlsZShjdHgsIGFycm93T3B0cyk7XG4gIHNldEJvcmRlclN0eWxlKGN0eCwgYXJyb3dPcHRzKTtcbiAgY3R4Lm1vdmVUbyhhcnJvd09mZnNldFgsIC13aWR0aCk7XG4gIGN0eC5saW5lVG8ob2Zmc2V0ICsgYWRqdXN0LCAwKTtcbiAgY3R4LmxpbmVUbyhhcnJvd09mZnNldFgsIHdpZHRoKTtcbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yIHx8IGJvcmRlckNvbG9yO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5zaGFkb3dDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNoYWRvd0NvbG9yID0gYXJyb3dPcHRzLmJvcmRlclNoYWRvd0NvbG9yO1xuICB9XG4gIGN0eC5zdHJva2UoKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbFBvaW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIGRpc3RhbmNlKSB7XG4gIGNvbnN0IHt4LCB5LCB4MiwgeTIsIGNlbnRlclgsIGNlbnRlcll9ID0gcHJvcGVydGllcztcbiAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geSwgeDIgLSB4KTtcbiAgY29uc3QgY3AgPSB0b1Bvc2l0aW9uKG9wdGlvbnMuY29udHJvbFBvaW50LCAwKTtcbiAgY29uc3QgcG9pbnQgPSB7XG4gICAgeDogY2VudGVyWCArIGdldFNpemUoZGlzdGFuY2UsIGNwLngsIGZhbHNlKSxcbiAgICB5OiBjZW50ZXJZICsgZ2V0U2l6ZShkaXN0YW5jZSwgY3AueSwgZmFsc2UpXG4gIH07XG4gIHJldHVybiByb3RhdGVkKHBvaW50LCB7eDogY2VudGVyWCwgeTogY2VudGVyWX0sIGFuZ2xlKTtcbn1cblxuZnVuY3Rpb24gZHJhd0Fycm93SGVhZE9uQ3VydmUoY3R4LCB7eCwgeX0sIHthbmdsZSwgYWRqdXN0fSwgYXJyb3dPcHRzKSB7XG4gIGlmICghYXJyb3dPcHRzIHx8ICFhcnJvd09wdHMuZGlzcGxheSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgZHJhd0Fycm93SGVhZChjdHgsIDAsIC1hZGp1c3QsIGFycm93T3B0cyk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdDdXJ2ZShjdHgsIGVsZW1lbnQsIGNwLCBsZW5ndGgpIHtcbiAgY29uc3Qge3gsIHksIHgyLCB5Miwgb3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7c3RhcnRPcHRzLCBlbmRPcHRzLCBzdGFydEFkanVzdCwgZW5kQWRqdXN0fSA9IGdldEFycm93SGVhZHMoZWxlbWVudCk7XG4gIGNvbnN0IHAxID0ge3gsIHl9O1xuICBjb25zdCBwMiA9IHt4OiB4MiwgeTogeTJ9O1xuICBjb25zdCBzdGFydEFuZ2xlID0gYW5nbGVJbkN1cnZlKHAxLCBjcCwgcDIsIDApO1xuICBjb25zdCBlbmRBbmdsZSA9IGFuZ2xlSW5DdXJ2ZShwMSwgY3AsIHAyLCAxKSAtIFBJO1xuICBjb25zdCBwcyA9IHBvaW50SW5DdXJ2ZShwMSwgY3AsIHAyLCBzdGFydEFkanVzdCAvIGxlbmd0aCk7XG4gIGNvbnN0IHBlID0gcG9pbnRJbkN1cnZlKHAxLCBjcCwgcDIsIDEgLSBlbmRBZGp1c3QgLyBsZW5ndGgpO1xuXG4gIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aC5tb3ZlVG8ocHMueCwgcHMueSk7XG4gIHBhdGgucXVhZHJhdGljQ3VydmVUbyhjcC54LCBjcC55LCBwZS54LCBwZS55KTtcbiAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5ib3JkZXJTaGFkb3dDb2xvcjtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbiAgZWxlbWVudC5wYXRoID0gcGF0aDtcbiAgZWxlbWVudC5jdHggPSBjdHg7XG4gIGRyYXdBcnJvd0hlYWRPbkN1cnZlKGN0eCwgcHMsIHthbmdsZTogc3RhcnRBbmdsZSwgYWRqdXN0OiBzdGFydEFkanVzdH0sIHN0YXJ0T3B0cyk7XG4gIGRyYXdBcnJvd0hlYWRPbkN1cnZlKGN0eCwgcGUsIHthbmdsZTogZW5kQW5nbGUsIGFkanVzdDogZW5kQWRqdXN0fSwgZW5kT3B0cyk7XG59XG5cbmNsYXNzIEVsbGlwc2VBbm5vdGF0aW9uIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5vcHRpb25zLnJvdGF0aW9uO1xuICAgIGNvbnN0IGhpdFNpemUgPSAodGhpcy5vcHRpb25zLmJvcmRlcldpZHRoICsgdGhpcy5vcHRpb25zLmhpdFRvbGVyYW5jZSkgLyAyO1xuICAgIGlmIChheGlzICE9PSAneCcgJiYgYXhpcyAhPT0gJ3knKSB7XG4gICAgICByZXR1cm4gcG9pbnRJbkVsbGlwc2Uoe3g6IG1vdXNlWCwgeTogbW91c2VZfSwgdGhpcy5nZXRQcm9wcyhbJ3dpZHRoJywgJ2hlaWdodCcsICdjZW50ZXJYJywgJ2NlbnRlclknXSwgdXNlRmluYWxQb3NpdGlvbiksIHJvdGF0aW9uLCBoaXRTaXplKTtcbiAgICB9XG4gICAgY29uc3Qge3gsIHksIHgyLCB5Mn0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ3gyJywgJ3kyJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGxpbWl0ID0gYXhpcyA9PT0gJ3knID8ge3N0YXJ0OiB5LCBlbmQ6IHkyfSA6IHtzdGFydDogeCwgZW5kOiB4Mn07XG4gICAgY29uc3Qgcm90YXRlZFBvaW50ID0gcm90YXRlZCh7eDogbW91c2VYLCB5OiBtb3VzZVl9LCB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pLCB0b1JhZGlhbnMoLXJvdGF0aW9uKSk7XG4gICAgcmV0dXJuIHJvdGF0ZWRQb2ludFtheGlzXSA+PSBsaW1pdC5zdGFydCAtIGhpdFNpemUgLSBFUFNJTE9OICYmIHJvdGF0ZWRQb2ludFtheGlzXSA8PSBsaW1pdC5lbmQgKyBoaXRTaXplICsgRVBTSUxPTjtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gZ2V0RWxlbWVudENlbnRlclBvaW50KHRoaXMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgdHJhbnNsYXRlKGN0eCwgdGhpcy5nZXRDZW50ZXJQb2ludCgpLCBvcHRpb25zLnJvdGF0aW9uKTtcbiAgICBzZXRTaGFkb3dTdHlsZShjdHgsIHRoaXMub3B0aW9ucyk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjb25zdCBzdHJva2UgPSBzZXRCb3JkZXJTdHlsZShjdHgsIG9wdGlvbnMpO1xuICAgIGN0eC5lbGxpcHNlKGNlbnRlclgsIGNlbnRlclksIGhlaWdodCAvIDIsIHdpZHRoIC8gMiwgUEkgLyAyLCAwLCAyICogUEkpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5ib3JkZXJTaGFkb3dDb2xvcjtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGdldCBsYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cyAmJiB0aGlzLmVsZW1lbnRzWzBdO1xuICB9XG5cbiAgcmVzb2x2ZUVsZW1lbnRQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlc29sdmVCb3hBbmRMYWJlbFByb3BlcnRpZXMoY2hhcnQsIG9wdGlvbnMpO1xuICB9XG5cbn1cblxuRWxsaXBzZUFubm90YXRpb24uaWQgPSAnZWxsaXBzZUFubm90YXRpb24nO1xuXG5FbGxpcHNlQW5ub3RhdGlvbi5kZWZhdWx0cyA9IHtcbiAgYWRqdXN0U2NhbGVSYW5nZTogdHJ1ZSxcbiAgYmFja2dyb3VuZFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVyU2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gIGJvcmRlcldpZHRoOiAxLFxuICBkaXNwbGF5OiB0cnVlLFxuICBoaXRUb2xlcmFuY2U6IDAsXG4gIGluaXQ6IHVuZGVmaW5lZCxcbiAgbGFiZWw6IE9iamVjdC5hc3NpZ24oe30sIEJveEFubm90YXRpb24uZGVmYXVsdHMubGFiZWwpLFxuICByb3RhdGlvbjogMCxcbiAgc2hhZG93Qmx1cjogMCxcbiAgc2hhZG93T2Zmc2V0WDogMCxcbiAgc2hhZG93T2Zmc2V0WTogMCxcbiAgeE1heDogdW5kZWZpbmVkLFxuICB4TWluOiB1bmRlZmluZWQsXG4gIHhTY2FsZUlEOiB1bmRlZmluZWQsXG4gIHlNYXg6IHVuZGVmaW5lZCxcbiAgeU1pbjogdW5kZWZpbmVkLFxuICB5U2NhbGVJRDogdW5kZWZpbmVkLFxuICB6OiAwXG59O1xuXG5FbGxpcHNlQW5ub3RhdGlvbi5kZWZhdWx0Um91dGVzID0ge1xuICBib3JkZXJDb2xvcjogJ2NvbG9yJyxcbiAgYmFja2dyb3VuZENvbG9yOiAnY29sb3InXG59O1xuXG5FbGxpcHNlQW5ub3RhdGlvbi5kZXNjcmlwdG9ycyA9IHtcbiAgbGFiZWw6IHtcbiAgICBfZmFsbGJhY2s6IHRydWVcbiAgfVxufTtcblxuZnVuY3Rpb24gcG9pbnRJbkVsbGlwc2UocCwgZWxsaXBzZSwgcm90YXRpb24sIGhpdFNpemUpIHtcbiAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlcll9ID0gZWxsaXBzZTtcbiAgY29uc3QgeFJhZGl1cyA9IHdpZHRoIC8gMjtcbiAgY29uc3QgeVJhZGl1cyA9IGhlaWdodCAvIDI7XG5cbiAgaWYgKHhSYWRpdXMgPD0gMCB8fCB5UmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzk0NjE4Ny9wb2ludC1hbmQtZWxsaXBzZS1yb3RhdGVkLXBvc2l0aW9uLXRlc3QtYWxnb3JpdGhtXG4gIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHJvdGF0aW9uIHx8IDApO1xuICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IGEgPSBNYXRoLnBvdyhjb3NBbmdsZSAqIChwLnggLSBjZW50ZXJYKSArIHNpbkFuZ2xlICogKHAueSAtIGNlbnRlclkpLCAyKTtcbiAgY29uc3QgYiA9IE1hdGgucG93KHNpbkFuZ2xlICogKHAueCAtIGNlbnRlclgpIC0gY29zQW5nbGUgKiAocC55IC0gY2VudGVyWSksIDIpO1xuICByZXR1cm4gKGEgLyBNYXRoLnBvdyh4UmFkaXVzICsgaGl0U2l6ZSwgMikpICsgKGIgLyBNYXRoLnBvdyh5UmFkaXVzICsgaGl0U2l6ZSwgMikpIDw9IDEuMDAwMTtcbn1cblxuY2xhc3MgUG9pbnRBbm5vdGF0aW9uIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCB4MiwgeTIsIHdpZHRofSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAneDInLCAneTInLCAnd2lkdGgnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaGl0U2l6ZSA9ICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGggKyB0aGlzLm9wdGlvbnMuaGl0VG9sZXJhbmNlKSAvIDI7XG4gICAgaWYgKGF4aXMgIT09ICd4JyAmJiBheGlzICE9PSAneScpIHtcbiAgICAgIHJldHVybiBpblBvaW50UmFuZ2Uoe3g6IG1vdXNlWCwgeTogbW91c2VZfSwgdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSwgd2lkdGggLyAyLCBoaXRTaXplKTtcbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSBheGlzID09PSAneScgPyB7c3RhcnQ6IHksIGVuZDogeTIsIHZhbHVlOiBtb3VzZVl9IDoge3N0YXJ0OiB4LCBlbmQ6IHgyLCB2YWx1ZTogbW91c2VYfTtcbiAgICByZXR1cm4gaW5MaW1pdChsaW1pdCwgaGl0U2l6ZSk7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRDZW50ZXJQb2ludCh0aGlzLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgaWYgKG9wdGlvbnMucmFkaXVzIDwgMC4xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIHNldFNoYWRvd1N0eWxlKGN0eCwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc3Ryb2tlID0gc2V0Qm9yZGVyU3R5bGUoY3R4LCBvcHRpb25zKTtcbiAgICBkcmF3UG9pbnQoY3R4LCB0aGlzLCB0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XG4gICAgaWYgKHN0cm9rZSAmJiAhaXNJbWFnZU9yQ2FudmFzKG9wdGlvbnMucG9pbnRTdHlsZSkpIHtcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IG9wdGlvbnMuYm9yZGVyU2hhZG93Q29sb3I7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IGJvcmRlcldpZHRoO1xuICB9XG5cbiAgcmVzb2x2ZUVsZW1lbnRQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHJlc29sdmVQb2ludFByb3BlcnRpZXMoY2hhcnQsIG9wdGlvbnMpO1xuICAgIHByb3BlcnRpZXMuaW5pdFByb3BlcnRpZXMgPSBpbml0QW5pbWF0aW9uUHJvcGVydGllcyhjaGFydCwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbn1cblxuUG9pbnRBbm5vdGF0aW9uLmlkID0gJ3BvaW50QW5ub3RhdGlvbic7XG5cblBvaW50QW5ub3RhdGlvbi5kZWZhdWx0cyA9IHtcbiAgYWRqdXN0U2NhbGVSYW5nZTogdHJ1ZSxcbiAgYmFja2dyb3VuZFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVyU2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gIGJvcmRlcldpZHRoOiAxLFxuICBkaXNwbGF5OiB0cnVlLFxuICBoaXRUb2xlcmFuY2U6IDAsXG4gIGluaXQ6IHVuZGVmaW5lZCxcbiAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gIHJhZGl1czogMTAsXG4gIHJvdGF0aW9uOiAwLFxuICBzaGFkb3dCbHVyOiAwLFxuICBzaGFkb3dPZmZzZXRYOiAwLFxuICBzaGFkb3dPZmZzZXRZOiAwLFxuICB4QWRqdXN0OiAwLFxuICB4TWF4OiB1bmRlZmluZWQsXG4gIHhNaW46IHVuZGVmaW5lZCxcbiAgeFNjYWxlSUQ6IHVuZGVmaW5lZCxcbiAgeFZhbHVlOiB1bmRlZmluZWQsXG4gIHlBZGp1c3Q6IDAsXG4gIHlNYXg6IHVuZGVmaW5lZCxcbiAgeU1pbjogdW5kZWZpbmVkLFxuICB5U2NhbGVJRDogdW5kZWZpbmVkLFxuICB5VmFsdWU6IHVuZGVmaW5lZCxcbiAgejogMFxufTtcblxuUG9pbnRBbm5vdGF0aW9uLmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJvcmRlckNvbG9yOiAnY29sb3InLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICdjb2xvcidcbn07XG5cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChheGlzICE9PSAneCcgJiYgYXhpcyAhPT0gJ3knKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJhZGl1cyA+PSAwLjEgJiYgdGhpcy5lbGVtZW50cy5sZW5ndGggPiAxICYmIHBvaW50SXNJblBvbHlnb24odGhpcy5lbGVtZW50cywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICBjb25zdCByb3RhdGVkUG9pbnQgPSByb3RhdGVkKHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0sIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbiksIHRvUmFkaWFucygtdGhpcy5vcHRpb25zLnJvdGF0aW9uKSk7XG4gICAgY29uc3QgYXhpc1BvaW50cyA9IHRoaXMuZWxlbWVudHMubWFwKChwb2ludCkgPT4gYXhpcyA9PT0gJ3knID8gcG9pbnQuYlkgOiBwb2ludC5iWCk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbiguLi5heGlzUG9pbnRzKTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1heCguLi5heGlzUG9pbnRzKTtcbiAgICByZXR1cm4gcm90YXRlZFBvaW50W2F4aXNdID49IHN0YXJ0ICYmIHJvdGF0ZWRQb2ludFtheGlzXSA8PSBlbmQ7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRDZW50ZXJQb2ludCh0aGlzLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2VsZW1lbnRzLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIHNldFNoYWRvd1N0eWxlKGN0eCwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc3Ryb2tlID0gc2V0Qm9yZGVyU3R5bGUoY3R4LCBvcHRpb25zKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBjdHgubW92ZVRvKGVsLngsIGVsLnkpO1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmxpbmVUbyhlbC54LCBlbC55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgLy8gSWYgbm8gYm9yZGVyLCBkb24ndCBkcmF3IGl0XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gb3B0aW9ucy5ib3JkZXJTaGFkb3dDb2xvcjtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIHJlc29sdmVFbGVtZW50UHJvcGVydGllcyhjaGFydCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSByZXNvbHZlUG9pbnRQcm9wZXJ0aWVzKGNoYXJ0LCBvcHRpb25zKTtcbiAgICBjb25zdCB7c2lkZXMsIHJvdGF0aW9ufSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBhbmdsZSA9ICgyICogUEkpIC8gc2lkZXM7XG4gICAgbGV0IHJhZCA9IHJvdGF0aW9uICogUkFEX1BFUl9ERUc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlczsgaSsrLCByYWQgKz0gYW5nbGUpIHtcbiAgICAgIGNvbnN0IGVsUHJvcHMgPSBidWlsZFBvaW50RWxlbWVudChwcm9wZXJ0aWVzLCBvcHRpb25zLCByYWQpO1xuICAgICAgZWxQcm9wcy5pbml0UHJvcGVydGllcyA9IGluaXRBbmltYXRpb25Qcm9wZXJ0aWVzKGNoYXJ0LCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWxQcm9wcyk7XG4gICAgfVxuICAgIHByb3BlcnRpZXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxufVxuXG5Qb2x5Z29uQW5ub3RhdGlvbi5pZCA9ICdwb2x5Z29uQW5ub3RhdGlvbic7XG5cblBvbHlnb25Bbm5vdGF0aW9uLmRlZmF1bHRzID0ge1xuICBhZGp1c3RTY2FsZVJhbmdlOiB0cnVlLFxuICBiYWNrZ3JvdW5kU2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gIGJvcmRlckRhc2g6IFtdLFxuICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gIGJvcmRlclNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuICBib3JkZXJXaWR0aDogMSxcbiAgZGlzcGxheTogdHJ1ZSxcbiAgaGl0VG9sZXJhbmNlOiAwLFxuICBpbml0OiB1bmRlZmluZWQsXG4gIHBvaW50OiB7XG4gICAgcmFkaXVzOiAwXG4gIH0sXG4gIHJhZGl1czogMTAsXG4gIHJvdGF0aW9uOiAwLFxuICBzaGFkb3dCbHVyOiAwLFxuICBzaGFkb3dPZmZzZXRYOiAwLFxuICBzaGFkb3dPZmZzZXRZOiAwLFxuICBzaWRlczogMyxcbiAgeEFkanVzdDogMCxcbiAgeE1heDogdW5kZWZpbmVkLFxuICB4TWluOiB1bmRlZmluZWQsXG4gIHhTY2FsZUlEOiB1bmRlZmluZWQsXG4gIHhWYWx1ZTogdW5kZWZpbmVkLFxuICB5QWRqdXN0OiAwLFxuICB5TWF4OiB1bmRlZmluZWQsXG4gIHlNaW46IHVuZGVmaW5lZCxcbiAgeVNjYWxlSUQ6IHVuZGVmaW5lZCxcbiAgeVZhbHVlOiB1bmRlZmluZWQsXG4gIHo6IDBcbn07XG5cblBvbHlnb25Bbm5vdGF0aW9uLmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJvcmRlckNvbG9yOiAnY29sb3InLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICdjb2xvcidcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRFbGVtZW50KHtjZW50ZXJYLCBjZW50ZXJZfSwge3JhZGl1cywgYm9yZGVyV2lkdGgsIGhpdFRvbGVyYW5jZX0sIHJhZCkge1xuICBjb25zdCBoaXRTaXplID0gKGJvcmRlcldpZHRoICsgaGl0VG9sZXJhbmNlKSAvIDI7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKHJhZCk7XG4gIGNvbnN0IGNvcyA9IE1hdGguY29zKHJhZCk7XG4gIGNvbnN0IHBvaW50ID0ge3g6IGNlbnRlclggKyBzaW4gKiByYWRpdXMsIHk6IGNlbnRlclkgLSBjb3MgKiByYWRpdXN9O1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdwb2ludCcsXG4gICAgb3B0aW9uU2NvcGU6ICdwb2ludCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgeDogcG9pbnQueCxcbiAgICAgIHk6IHBvaW50LnksXG4gICAgICBjZW50ZXJYOiBwb2ludC54LFxuICAgICAgY2VudGVyWTogcG9pbnQueSxcbiAgICAgIGJYOiBjZW50ZXJYICsgc2luICogKHJhZGl1cyArIGhpdFNpemUpLFxuICAgICAgYlk6IGNlbnRlclkgLSBjb3MgKiAocmFkaXVzICsgaGl0U2l6ZSlcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBvaW50SXNJblBvbHlnb24ocG9pbnRzLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpc0luc2lkZSA9IGZhbHNlO1xuICBsZXQgQSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uZ2V0UHJvcHMoWydiWCcsICdiWSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICBjb25zdCBCID0gcG9pbnQuZ2V0UHJvcHMoWydiWCcsICdiWSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoKEIuYlkgPiB5KSAhPT0gKEEuYlkgPiB5KSAmJiB4IDwgKEEuYlggLSBCLmJYKSAqICh5IC0gQi5iWSkgLyAoQS5iWSAtIEIuYlkpICsgQi5iWCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICAgIEEgPSBCO1xuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cblxuY29uc3QgYW5ub3RhdGlvblR5cGVzID0ge1xuICBib3g6IEJveEFubm90YXRpb24sXG4gIGRvdWdobnV0TGFiZWw6IERvdWdobnV0TGFiZWxBbm5vdGF0aW9uLFxuICBlbGxpcHNlOiBFbGxpcHNlQW5ub3RhdGlvbixcbiAgbGFiZWw6IExhYmVsQW5ub3RhdGlvbixcbiAgbGluZTogTGluZUFubm90YXRpb24sXG4gIHBvaW50OiBQb2ludEFubm90YXRpb24sXG4gIHBvbHlnb246IFBvbHlnb25Bbm5vdGF0aW9uXG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGZhbGxiYWNrIGZvciBhbm5vdGF0aW9uIGVsZW1lbnRzXG4gKiBGb3IgZXhhbXBsZSBsaW5lQW5ub3RhdGlvbiBvcHRpb25zIHdvdWxkIGJlIGxvb2tlZCB0aHJvdWdoOlxuICogLSB0aGUgYW5ub3RhdGlvbiBvYmplY3QgKG9wdGlvbnMucGx1Z2lucy5hbm5vdGF0aW9uLmFubm90YXRpb25zW2lkXSlcbiAqIC0gZWxlbWVudCBvcHRpb25zIChvcHRpb25zLmVsZW1lbnRzLmxpbmVBbm5vdGF0aW9uKVxuICogLSBlbGVtZW50IGRlZmF1bHRzIChkZWZhdWx0cy5lbGVtZW50cy5saW5lQW5ub3RhdGlvbilcbiAqIC0gYW5ub3RhdGlvbiBwbHVnaW4gZGVmYXVsdHMgKGRlZmF1bHRzLnBsdWdpbnMuYW5ub3RhdGlvbiwgdGhpcyBpcyB3aGF0IHdlIGFyZSByZWdpc3RlcmluZyBoZXJlKVxuICovXG5PYmplY3Qua2V5cyhhbm5vdGF0aW9uVHlwZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgZGVmYXVsdHMuZGVzY3JpYmUoYGVsZW1lbnRzLiR7YW5ub3RhdGlvblR5cGVzW2tleV0uaWR9YCwge1xuICAgIF9mYWxsYmFjazogJ3BsdWdpbnMuYW5ub3RhdGlvbi5jb21tb24nXG4gIH0pO1xufSk7XG5cbmNvbnN0IGRpcmVjdFVwZGF0ZXIgPSB7XG4gIHVwZGF0ZTogT2JqZWN0LmFzc2lnblxufTtcblxuY29uc3QgaG9va3MkMSA9IGV2ZW50SG9va3MuY29uY2F0KGVsZW1lbnRIb29rcyk7XG5jb25zdCByZXNvbHZlID0gKHZhbHVlLCBvcHREZWZzKSA9PiBpc09iamVjdChvcHREZWZzKSA/IHJlc29sdmVPYmoodmFsdWUsIG9wdERlZnMpIDogdmFsdWU7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydChcImNoYXJ0LmpzXCIpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KFwiY2hhcnQuanNcIikuVXBkYXRlTW9kZSB9IFVwZGF0ZU1vZGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9vcHRpb25zJykuQW5ub3RhdGlvblBsdWdpbk9wdGlvbnMgfSBBbm5vdGF0aW9uUGx1Z2luT3B0aW9uc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc0luZGV4YWJsZSA9IChwcm9wKSA9PiBwcm9wID09PSAnY29sb3InIHx8IHByb3AgPT09ICdmb250JztcblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBhbm5vdGF0aW9uIHR5cGUsIGNoZWNraW5nIGlmIGlzIHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1saW5lXSAtIGFubm90YXRpb24gdHlwZVxuICogQHJldHVybnMge3N0cmluZ30gcmVzb2x2ZWQgYW5ub3RhdGlvbiB0eXBlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUeXBlKHR5cGUgPSAnbGluZScpIHtcbiAgaWYgKGFubm90YXRpb25UeXBlc1t0eXBlXSkge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGNvbnNvbGUud2FybihgVW5rbm93biBhbm5vdGF0aW9uIHR5cGU6ICcke3R5cGV9JywgZGVmYXVsdGluZyB0byAnbGluZSdgKTtcbiAgcmV0dXJuICdsaW5lJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0Fubm90YXRpb25QbHVnaW5PcHRpb25zfSBvcHRpb25zXG4gKiBAcGFyYW0ge1VwZGF0ZU1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRWxlbWVudHMoY2hhcnQsIHN0YXRlLCBvcHRpb25zLCBtb2RlKSB7XG4gIGNvbnN0IGFuaW1hdGlvbnMgPSByZXNvbHZlQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucy5hbmltYXRpb25zLCBtb2RlKTtcblxuICBjb25zdCBhbm5vdGF0aW9ucyA9IHN0YXRlLmFubm90YXRpb25zO1xuICBjb25zdCBlbGVtZW50cyA9IHJlc3luY0VsZW1lbnRzKHN0YXRlLmVsZW1lbnRzLCBhbm5vdGF0aW9ucyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFubm90YXRpb25PcHRpb25zID0gYW5ub3RhdGlvbnNbaV07XG4gICAgY29uc3QgZWxlbWVudCA9IGdldE9yQ3JlYXRlRWxlbWVudChlbGVtZW50cywgaSwgYW5ub3RhdGlvbk9wdGlvbnMudHlwZSk7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBhbm5vdGF0aW9uT3B0aW9ucy5zZXRDb250ZXh0KGdldENvbnRleHQoY2hhcnQsIGVsZW1lbnQsIGVsZW1lbnRzLCBhbm5vdGF0aW9uT3B0aW9ucykpO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBlbGVtZW50LnJlc29sdmVFbGVtZW50UHJvcGVydGllcyhjaGFydCwgcmVzb2x2ZXIpO1xuXG4gICAgcHJvcGVydGllcy5za2lwID0gdG9Ta2lwKHByb3BlcnRpZXMpO1xuXG4gICAgaWYgKCdlbGVtZW50cycgaW4gcHJvcGVydGllcykge1xuICAgICAgdXBkYXRlU3ViRWxlbWVudHMoZWxlbWVudCwgcHJvcGVydGllcy5lbGVtZW50cywgcmVzb2x2ZXIsIGFuaW1hdGlvbnMpO1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzdWItZWxlbWVudCBkZWZpbml0aW9ucyBmcm9tIHByb3BlcnRpZXMsIHNvIHRoZSBhY3R1YWwgZWxlbWVudHNcbiAgICAgIC8vIGFyZSBub3Qgb3ZlcndyaXR0ZW4gYnkgdGhlaXIgZGVmaW5pdGlvbnNcbiAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLmVsZW1lbnRzO1xuICAgIH1cblxuICAgIGlmICghZGVmaW5lZChlbGVtZW50LngpKSB7XG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBuZXdseSBjcmVhdGVkLCBhc3NpbmcgdGhlIHByb3BlcnRpZXMgZGlyZWN0bHkgLSB0b1xuICAgICAgLy8gbWFrZSB0aGVtIHJlYWRpbHkgYXdhaWxhYmxlIHRvIGFueSBzY3JpcHRhYmxlIG9wdGlvbnMuIElmIHdlIGRvIG5vdCBkbyB0aGlzLFxuICAgICAgLy8gdGhlIHByb3BlcnRpZXMgcmV0cnVuZWQgYnkgYHJlc29sdmVFbGVtZW50UHJvcGVydGllc2AgYXJlIGF2YWlsYWJsZSBvbmx5XG4gICAgICAvLyBhZnRlciBvcHRpb25zIHJlc29sdXRpb24uXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcy5pbml0UHJvcGVydGllcyk7XG4gICAgcHJvcGVydGllcy5vcHRpb25zID0gcmVzb2x2ZUFubm90YXRpb25PcHRpb25zKHJlc29sdmVyKTtcblxuICAgIGFuaW1hdGlvbnMudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU2tpcChwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBpc05hTihwcm9wZXJ0aWVzLngpIHx8IGlzTmFOKHByb3BlcnRpZXMueSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBbmltYXRpb25zKGNoYXJ0LCBhbmltT3B0cywgbW9kZSkge1xuICBpZiAobW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZScgfHwgbW9kZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICByZXR1cm4gZGlyZWN0VXBkYXRlcjtcbiAgfVxuICByZXR1cm4gbmV3IEFuaW1hdGlvbnMoY2hhcnQsIGFuaW1PcHRzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3ViRWxlbWVudHMobWFpbkVsZW1lbnQsIGVsZW1lbnRzLCByZXNvbHZlciwgYW5pbWF0aW9ucykge1xuICBjb25zdCBzdWJFbGVtZW50cyA9IG1haW5FbGVtZW50LmVsZW1lbnRzIHx8IChtYWluRWxlbWVudC5lbGVtZW50cyA9IFtdKTtcbiAgc3ViRWxlbWVudHMubGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGVsZW1lbnRzW2ldO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkZWZpbml0aW9uLnByb3BlcnRpZXM7XG4gICAgY29uc3Qgc3ViRWxlbWVudCA9IGdldE9yQ3JlYXRlRWxlbWVudChzdWJFbGVtZW50cywgaSwgZGVmaW5pdGlvbi50eXBlLCBkZWZpbml0aW9uLmluaXRQcm9wZXJ0aWVzKTtcbiAgICBjb25zdCBzdWJSZXNvbHZlciA9IHJlc29sdmVyW2RlZmluaXRpb24ub3B0aW9uU2NvcGVdLm92ZXJyaWRlKGRlZmluaXRpb24pO1xuICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHJlc29sdmVBbm5vdGF0aW9uT3B0aW9ucyhzdWJSZXNvbHZlcik7XG4gICAgYW5pbWF0aW9ucy51cGRhdGUoc3ViRWxlbWVudCwgcHJvcGVydGllcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVFbGVtZW50KGVsZW1lbnRzLCBpbmRleCwgdHlwZSwgaW5pdFByb3BlcnRpZXMpIHtcbiAgY29uc3QgZWxlbWVudENsYXNzID0gYW5ub3RhdGlvblR5cGVzW3Jlc29sdmVUeXBlKHR5cGUpXTtcbiAgbGV0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XG4gIGlmICghZWxlbWVudCB8fCAhKGVsZW1lbnQgaW5zdGFuY2VvZiBlbGVtZW50Q2xhc3MpKSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XSA9IG5ldyBlbGVtZW50Q2xhc3MoKTtcbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIGluaXRQcm9wZXJ0aWVzKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFubm90YXRpb25PcHRpb25zKHJlc29sdmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRDbGFzcyA9IGFubm90YXRpb25UeXBlc1tyZXNvbHZlVHlwZShyZXNvbHZlci50eXBlKV07XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICByZXN1bHQuaWQgPSByZXNvbHZlci5pZDtcbiAgcmVzdWx0LnR5cGUgPSByZXNvbHZlci50eXBlO1xuICByZXN1bHQuZHJhd1RpbWUgPSByZXNvbHZlci5kcmF3VGltZTtcbiAgT2JqZWN0LmFzc2lnbihyZXN1bHQsXG4gICAgcmVzb2x2ZU9iaihyZXNvbHZlciwgZWxlbWVudENsYXNzLmRlZmF1bHRzKSxcbiAgICByZXNvbHZlT2JqKHJlc29sdmVyLCBlbGVtZW50Q2xhc3MuZGVmYXVsdFJvdXRlcykpO1xuICBmb3IgKGNvbnN0IGhvb2sgb2YgaG9va3MkMSkge1xuICAgIHJlc3VsdFtob29rXSA9IHJlc29sdmVyW2hvb2tdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVPYmoocmVzb2x2ZXIsIGRlZnMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhkZWZzKSkge1xuICAgIGNvbnN0IG9wdERlZnMgPSBkZWZzW3Byb3BdO1xuICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZXJbcHJvcF07XG4gICAgaWYgKGlzSW5kZXhhYmxlKHByb3ApICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IHJlc29sdmUoaXRlbSwgb3B0RGVmcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSByZXNvbHZlKHZhbHVlLCBvcHREZWZzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dChjaGFydCwgZWxlbWVudCwgZWxlbWVudHMsIGFubm90YXRpb24pIHtcbiAgcmV0dXJuIGVsZW1lbnQuJGNvbnRleHQgfHwgKGVsZW1lbnQuJGNvbnRleHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoY2hhcnQuZ2V0Q29udGV4dCgpKSwge1xuICAgIGVsZW1lbnQsXG4gICAgZ2V0IGVsZW1lbnRzKCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigoZWwpID0+IGVsICYmIGVsLm9wdGlvbnMpO1xuICAgIH0sXG4gICAgaWQ6IGFubm90YXRpb24uaWQsXG4gICAgdHlwZTogJ2Fubm90YXRpb24nXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gcmVzeW5jRWxlbWVudHMoZWxlbWVudHMsIGFubm90YXRpb25zKSB7XG4gIGNvbnN0IGNvdW50ID0gYW5ub3RhdGlvbnMubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCBjb3VudCkge1xuICAgIGNvbnN0IGFkZCA9IGNvdW50IC0gc3RhcnQ7XG4gICAgZWxlbWVudHMuc3BsaWNlKHN0YXJ0LCAwLCAuLi5uZXcgQXJyYXkoYWRkKSk7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBjb3VudCkge1xuICAgIGVsZW1lbnRzLnNwbGljZShjb3VudCwgc3RhcnQgLSBjb3VudCk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMy4xLjBcIjtcblxuY29uc3QgY2hhcnRTdGF0ZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBpc05vdERvdWdobnV0TGFiZWwgPSBhbm5vdGF0aW9uID0+IGFubm90YXRpb24udHlwZSAhPT0gJ2RvdWdobnV0TGFiZWwnO1xuY29uc3QgaG9va3MgPSBldmVudEhvb2tzLmNvbmNhdChlbGVtZW50SG9va3MpO1xuXG52YXIgYW5ub3RhdGlvbiA9IHtcbiAgaWQ6ICdhbm5vdGF0aW9uJyxcblxuICB2ZXJzaW9uLFxuXG4gIGJlZm9yZVJlZ2lzdGVyKCkge1xuICAgIHJlcXVpcmVWZXJzaW9uKCdjaGFydC5qcycsICc0LjAnLCBDaGFydC52ZXJzaW9uKTtcbiAgfSxcblxuICBhZnRlclJlZ2lzdGVyKCkge1xuICAgIENoYXJ0LnJlZ2lzdGVyKGFubm90YXRpb25UeXBlcyk7XG4gIH0sXG5cbiAgYWZ0ZXJVbnJlZ2lzdGVyKCkge1xuICAgIENoYXJ0LnVucmVnaXN0ZXIoYW5ub3RhdGlvblR5cGVzKTtcbiAgfSxcblxuICBiZWZvcmVJbml0KGNoYXJ0KSB7XG4gICAgY2hhcnRTdGF0ZXMuc2V0KGNoYXJ0LCB7XG4gICAgICBhbm5vdGF0aW9uczogW10sXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICB2aXNpYmxlRWxlbWVudHM6IFtdLFxuICAgICAgbGlzdGVuZXJzOiB7fSxcbiAgICAgIGxpc3RlbmVkOiBmYWxzZSxcbiAgICAgIG1vdmVMaXN0ZW5lZDogZmFsc2UsXG4gICAgICBob29rczoge30sXG4gICAgICBob29rZWQ6IGZhbHNlLFxuICAgICAgaG92ZXJlZDogW11cbiAgICB9KTtcbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGNoYXJ0U3RhdGVzLmdldChjaGFydCk7XG4gICAgY29uc3QgYW5ub3RhdGlvbnMgPSBzdGF0ZS5hbm5vdGF0aW9ucyA9IFtdO1xuXG4gICAgbGV0IGFubm90YXRpb25PcHRpb25zID0gb3B0aW9ucy5hbm5vdGF0aW9ucztcbiAgICBpZiAoaXNPYmplY3QoYW5ub3RhdGlvbk9wdGlvbnMpKSB7XG4gICAgICBPYmplY3Qua2V5cyhhbm5vdGF0aW9uT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFubm90YXRpb25PcHRpb25zW2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZS5pZCA9IGtleTtcbiAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGFubm90YXRpb25PcHRpb25zKSkge1xuICAgICAgYW5ub3RhdGlvbnMucHVzaCguLi5hbm5vdGF0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIHZlcmlmeVNjYWxlT3B0aW9ucyhhbm5vdGF0aW9ucy5maWx0ZXIoaXNOb3REb3VnaG51dExhYmVsKSwgY2hhcnQuc2NhbGVzKTtcbiAgfSxcblxuICBhZnRlckRhdGFMaW1pdHMoY2hhcnQsIGFyZ3MpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGNoYXJ0U3RhdGVzLmdldChjaGFydCk7XG4gICAgYWRqdXN0U2NhbGVSYW5nZShjaGFydCwgYXJncy5zY2FsZSwgc3RhdGUuYW5ub3RhdGlvbnMuZmlsdGVyKGlzTm90RG91Z2hudXRMYWJlbCkuZmlsdGVyKGEgPT4gYS5kaXNwbGF5ICYmIGEuYWRqdXN0U2NhbGVSYW5nZSkpO1xuICB9LFxuXG4gIGFmdGVyVXBkYXRlKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBjaGFydFN0YXRlcy5nZXQoY2hhcnQpO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhjaGFydCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIHVwZGF0ZUVsZW1lbnRzKGNoYXJ0LCBzdGF0ZSwgb3B0aW9ucywgYXJncy5tb2RlKTtcbiAgICBzdGF0ZS52aXNpYmxlRWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cy5maWx0ZXIoZWwgPT4gIWVsLnNraXAgJiYgZWwub3B0aW9ucy5kaXNwbGF5KTtcbiAgICB1cGRhdGVIb29rcyhjaGFydCwgc3RhdGUsIG9wdGlvbnMpO1xuICB9LFxuXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYmVmb3JlRGF0YXNldHNEcmF3Jywgb3B0aW9ucy5jbGlwKTtcbiAgfSxcblxuICBhZnRlckRhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYWZ0ZXJEYXRhc2V0c0RyYXcnLCBvcHRpb25zLmNsaXApO1xuICB9LFxuXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGRyYXcoY2hhcnQsIF9hcmdzLmluZGV4LCBvcHRpb25zLmNsaXApO1xuICB9LFxuXG4gIGJlZm9yZURyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgZHJhdyhjaGFydCwgJ2JlZm9yZURyYXcnLCBvcHRpb25zLmNsaXApO1xuICB9LFxuXG4gIGFmdGVyRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBkcmF3KGNoYXJ0LCAnYWZ0ZXJEcmF3Jywgb3B0aW9ucy5jbGlwKTtcbiAgfSxcblxuICBiZWZvcmVFdmVudChjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gY2hhcnRTdGF0ZXMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoaGFuZGxlRXZlbnQoc3RhdGUsIGFyZ3MuZXZlbnQsIG9wdGlvbnMpKSB7XG4gICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckRlc3Ryb3koY2hhcnQpIHtcbiAgICBjaGFydFN0YXRlcy5kZWxldGUoY2hhcnQpO1xuICB9LFxuXG4gIGdldEFubm90YXRpb25zKGNoYXJ0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSBjaGFydFN0YXRlcy5nZXQoY2hhcnQpO1xuICAgIHJldHVybiBzdGF0ZSA/IHN0YXRlLmVsZW1lbnRzIDogW107XG4gIH0sXG5cbiAgLy8gb25seSBmb3IgdGVzdGluZ1xuICBfZ2V0QW5ub3RhdGlvbkVsZW1lbnRzQXRFdmVudEZvck1vZGUodmlzaWJsZUVsZW1lbnRzLCBldmVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRFbGVtZW50cyh2aXNpYmxlRWxlbWVudHMsIGV2ZW50LCBvcHRpb25zKTtcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAneDInLCAneTInLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NlbnRlclgnLCAnY2VudGVyWScsICdwb2ludFgnLCAncG9pbnRZJywgJ3JhZGl1cyddLFxuICAgICAgICB0eXBlOiAnbnVtYmVyJ1xuICAgICAgfSxcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBwcm9wZXJ0aWVzOiBbJ2JhY2tncm91bmRDb2xvcicsICdib3JkZXJDb2xvciddLFxuICAgICAgICB0eXBlOiAnY29sb3InXG4gICAgICB9XG4gICAgfSxcbiAgICBjbGlwOiB0cnVlLFxuICAgIGludGVyYWN0aW9uOiB7XG4gICAgICBtb2RlOiB1bmRlZmluZWQsXG4gICAgICBheGlzOiB1bmRlZmluZWQsXG4gICAgICBpbnRlcnNlY3Q6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgY29tbW9uOiB7XG4gICAgICBkcmF3VGltZTogJ2FmdGVyRGF0YXNldHNEcmF3JyxcbiAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgbGFiZWw6IHtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKHByb3ApID0+ICFob29rcy5pbmNsdWRlcyhwcm9wKSAmJiBwcm9wICE9PSAnaW5pdCcsXG4gICAgYW5ub3RhdGlvbnM6IHtcbiAgICAgIF9hbGxLZXlzOiBmYWxzZSxcbiAgICAgIF9mYWxsYmFjazogKHByb3AsIG9wdHMpID0+IGBlbGVtZW50cy4ke2Fubm90YXRpb25UeXBlc1tyZXNvbHZlVHlwZShvcHRzLnR5cGUpXS5pZH1gXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiB0cnVlXG4gICAgfSxcbiAgICBjb21tb246IHtcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIF9pbmRleGFibGU6IGlzSW5kZXhhYmxlLFxuICAgICAgICBfZmFsbGJhY2s6IHRydWVcbiAgICAgIH0sXG4gICAgICBfaW5kZXhhYmxlOiBpc0luZGV4YWJsZVxuICAgIH1cbiAgfSxcblxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJyddXG59O1xuXG5mdW5jdGlvbiBkcmF3KGNoYXJ0LCBjYWxsZXIsIGNsaXApIHtcbiAgY29uc3Qge2N0eCwgY2hhcnRBcmVhfSA9IGNoYXJ0O1xuICBjb25zdCBzdGF0ZSA9IGNoYXJ0U3RhdGVzLmdldChjaGFydCk7XG5cbiAgaWYgKGNsaXApIHtcbiAgICBjbGlwQXJlYShjdHgsIGNoYXJ0QXJlYSk7XG4gIH1cblxuICBjb25zdCBkcmF3YWJsZUVsZW1lbnRzID0gZ2V0RHJhd2FibGVFbGVtZW50cyhzdGF0ZS52aXNpYmxlRWxlbWVudHMsIGNhbGxlcikuc29ydCgoYSwgYikgPT4gYS5lbGVtZW50Lm9wdGlvbnMueiAtIGIuZWxlbWVudC5vcHRpb25zLnopO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgZHJhd2FibGVFbGVtZW50cykge1xuICAgIGRyYXdFbGVtZW50KGN0eCwgY2hhcnRBcmVhLCBzdGF0ZSwgaXRlbSk7XG4gIH1cblxuICBpZiAoY2xpcCkge1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREcmF3YWJsZUVsZW1lbnRzKGVsZW1lbnRzLCBjYWxsZXIpIHtcbiAgY29uc3QgZHJhd2FibGVFbGVtZW50cyA9IFtdO1xuICBmb3IgKGNvbnN0IGVsIG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsLm9wdGlvbnMuZHJhd1RpbWUgPT09IGNhbGxlcikge1xuICAgICAgZHJhd2FibGVFbGVtZW50cy5wdXNoKHtlbGVtZW50OiBlbCwgbWFpbjogdHJ1ZX0pO1xuICAgIH1cbiAgICBpZiAoZWwuZWxlbWVudHMgJiYgZWwuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IHN1YiBvZiBlbC5lbGVtZW50cykge1xuICAgICAgICBpZiAoc3ViLm9wdGlvbnMuZGlzcGxheSAmJiBzdWIub3B0aW9ucy5kcmF3VGltZSA9PT0gY2FsbGVyKSB7XG4gICAgICAgICAgZHJhd2FibGVFbGVtZW50cy5wdXNoKHtlbGVtZW50OiBzdWJ9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZHJhd2FibGVFbGVtZW50cztcbn1cblxuZnVuY3Rpb24gZHJhd0VsZW1lbnQoY3R4LCBjaGFydEFyZWEsIHN0YXRlLCBpdGVtKSB7XG4gIGNvbnN0IGVsID0gaXRlbS5lbGVtZW50O1xuICBpZiAoaXRlbS5tYWluKSB7XG4gICAgaW52b2tlSG9vayhzdGF0ZSwgZWwsICdiZWZvcmVEcmF3Jyk7XG4gICAgZWwuZHJhdyhjdHgsIGNoYXJ0QXJlYSk7XG4gICAgaW52b2tlSG9vayhzdGF0ZSwgZWwsICdhZnRlckRyYXcnKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5kcmF3KGN0eCwgY2hhcnRBcmVhKTtcbiAgfVxufVxuXG5leHBvcnQgeyBhbm5vdGF0aW9uIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJFbGVtZW50IiwiRG91Z2hudXRDb250cm9sbGVyIiwiZGVmYXVsdHMiLCJBbmltYXRpb25zIiwiQ2hhcnQiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJ0b1JhZGlhbnMiLCJpc09iamVjdCIsInZhbHVlT3JEZWZhdWx0IiwiZGVmaW5lZCIsImlzRnVuY3Rpb24iLCJjYWxsYmFjayIsImlzQXJyYXkiLCJ0b0ZvbnQiLCJhZGRSb3VuZGVkUmVjdFBhdGgiLCJ0b1RSQkxDb3JuZXJzIiwiUVVBUlRFUl9QSSIsIlBJIiwiSEFMRl9QSSIsIlRXT19USElSRFNfUEkiLCJUQVUiLCJpc051bWJlciIsIlJBRF9QRVJfREVHIiwidG9QYWRkaW5nIiwiaXNGaW5pdGUiLCJnZXRBbmdsZUZyb21Qb2ludCIsInRvRGVncmVlcyIsImNsaXBBcmVhIiwidW5jbGlwQXJlYSIsImludGVyYWN0aW9uIiwibW9kZXMiLCJwb2ludCIsInZpc2libGVFbGVtZW50cyIsImV2ZW50IiwiZmlsdGVyRWxlbWVudHMiLCJpbnRlcnNlY3QiLCJuZWFyZXN0Iiwib3B0aW9ucyIsImdldE5lYXJlc3RJdGVtIiwieCIsImF4aXMiLCJ5IiwiZ2V0RWxlbWVudHMiLCJtb2RlIiwiaW5SYW5nZUJ5QXhpcyIsImVsZW1lbnQiLCJpblJhbmdlIiwiZ2V0UG9pbnRCeUF4aXMiLCJjZW50ZXIiLCJmaWx0ZXIiLCJtaW5EaXN0YW5jZSIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwicmVkdWNlIiwibmVhcmVzdEl0ZW1zIiwiZ2V0Q2VudGVyUG9pbnQiLCJldmVuUG9pbnQiLCJkaXN0YW5jZSIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJfaW5kZXgiLCJzbGljZSIsInJvdGF0ZWQiLCJhbmdsZSIsImNvcyIsIk1hdGgiLCJzaW4iLCJjeCIsImN5IiwiaXNPbGRlclBhcnQiLCJhY3QiLCJyZXEiLCJsZW5ndGgiLCJFUFNJTE9OIiwiY2xhbXAiLCJmcm9tIiwidG8iLCJtaW4iLCJtYXgiLCJpbkxpbWl0IiwibGltaXQiLCJoaXRTaXplIiwidmFsdWUiLCJzdGFydCIsImVuZCIsImNsYW1wQWxsIiwib2JqIiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsImluUG9pbnRSYW5nZSIsInJhZGl1cyIsInBvdyIsImluQm94UmFuZ2UiLCJ4MiIsInkyIiwiYm9yZGVyV2lkdGgiLCJoaXRUb2xlcmFuY2UiLCJpblJhbmdlWCIsImluUmFuZ2VZIiwiaW5MYWJlbFJhbmdlIiwicmVjdCIsInJvdGF0aW9uIiwicm90UG9pbnQiLCJnZXRFbGVtZW50Q2VudGVyUG9pbnQiLCJ1c2VGaW5hbFBvc2l0aW9uIiwiY2VudGVyWCIsImNlbnRlclkiLCJnZXRQcm9wcyIsInJlcXVpcmVWZXJzaW9uIiwicGtnIiwidmVyIiwic3RyaWN0IiwicGFydHMiLCJzcGxpdCIsImkiLCJwYXJzZUludCIsIkVycm9yIiwiaXNQZXJjZW50U3RyaW5nIiwicyIsImVuZHNXaXRoIiwidG9QZXJjZW50IiwicGFyc2VGbG9hdCIsInRvUG9zaXRpdmVQZXJjZW50IiwiYm94QXBwZXJpbmciLCJ3aWR0aCIsImhlaWdodCIsImRlZmF1bHRJbml0QW5pbWF0aW9uIiwiYm94IiwicHJvcGVydGllcyIsImRvdWdobnV0TGFiZWwiLCJlbGxpcHNlIiwibGFiZWwiLCJsaW5lIiwicG9seWdvbiIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJzaXplIiwicG9zaXRpb24iLCJnZXRTaXplIiwicG9zaXRpdmVQZXJjZW50IiwiY2FsY3VsYXRlVGV4dEFsaWdubWVudCIsInRleHRBbGlnbiIsIm1lYXN1cmVMYWJlbFJlY3RhbmdsZSIsImxhYmVsU2l6ZSIsInhBZGp1c3QiLCJ5QWRqdXN0IiwicGFkZGluZyIsImhhc1BhZGRpbmciLCJwb3NpdGlvbk9iaiIsInRvUG9zaXRpb24iLCJjYWxjdWxhdGVMYWJlbFBvc2l0aW9uJDEiLCJkZWZhdWx0VmFsdWUiLCJzaG91bGRGaXQiLCJmaXRSYXRpbyIsImF1dG9GaXQiLCJ0b0ZvbnRzIiwib3B0Rm9udCIsImZvbnQiLCJmb250cyIsIm1hcCIsImYiLCJmbG9vciIsImxpbmVIZWlnaHQiLCJpc0JvdW5kVG9Qb2ludCIsInhWYWx1ZSIsInlWYWx1ZSIsImFkanVzdCIsImluaXRBbmltYXRpb25Qcm9wZXJ0aWVzIiwiY2hhcnQiLCJpbml0QW5pbSIsImluaXQiLCJhcHBseURlZmF1bHQiLCJleGVjQ2FsbGJhY2siLCJsb2FkSG9va3MiLCJob29rcyIsImhvb2tzQ29udGFpbmVyIiwiYWN0aXZhdGVkIiwiZm9yRWFjaCIsImhvb2siLCJ0eXBlIiwicmVzdWx0Iiwid2lkdGhDYWNoZSIsIk1hcCIsIm5vdFJhZGl1cyIsImlzTmFOIiwiZm9udHNLZXkiLCJwcmV2IiwiaXRlbSIsInN0cmluZyIsImlzSW1hZ2VPckNhbnZhcyIsImNvbnRlbnQiLCJ0b1N0cmluZyIsInRyYW5zbGF0ZSIsImN0eCIsInJvdGF0ZSIsInNldEJvcmRlclN0eWxlIiwibGluZUNhcCIsImJvcmRlckNhcFN0eWxlIiwic2V0TGluZURhc2giLCJib3JkZXJEYXNoIiwibGluZURhc2hPZmZzZXQiLCJib3JkZXJEYXNoT2Zmc2V0IiwibGluZUpvaW4iLCJib3JkZXJKb2luU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2VTdHlsZSIsImJvcmRlckNvbG9yIiwic2V0U2hhZG93U3R5bGUiLCJzaGFkb3dDb2xvciIsImJhY2tncm91bmRTaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJzaGFkb3dPZmZzZXRYIiwic2hhZG93T2Zmc2V0WSIsIm1lYXN1cmVMYWJlbFNpemUiLCJzdHJva2VXaWR0aCIsInRleHRTdHJva2VXaWR0aCIsImxpbmVzIiwibWFwS2V5Iiwiam9pbiIsIl9tZWFzdXJlVGV4dCIsImhhcyIsInNldCIsImNhbGN1bGF0ZUxhYmVsU2l6ZSIsImdldCIsImRyYXdCb3giLCJzYXZlIiwic3Ryb2tlIiwiZmlsbFN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiYmVnaW5QYXRoIiwidyIsImgiLCJib3JkZXJSYWRpdXMiLCJjbG9zZVBhdGgiLCJmaWxsIiwiYm9yZGVyU2hhZG93Q29sb3IiLCJyZXN0b3JlIiwiZHJhd0xhYmVsIiwiZ2xvYmFsQWxwaGEiLCJnZXRPcGFjaXR5Iiwib3BhY2l0eSIsInN0eWxlIiwiZHJhd0ltYWdlIiwibGFiZWxzIiwib3B0Q29sb3IiLCJjb2xvciIsImNvbG9ycyIsInRleHRCYXNlbGluZSIsInNldFRleHRTdHJva2VTdHlsZSIsImFwcGx5TGFiZWxEZWNvcmF0aW9uIiwiYXBwbHlMYWJlbENvbnRlbnQiLCJtaXRlckxpbWl0IiwidGV4dFN0cm9rZUNvbG9yIiwiZHJhd1BvaW50IiwicG9pbnRTdHlsZSIsInJhZCIsImRyYXdQb2ludFN0eWxlIiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXJSYWRpdXMiLCJhcmMiLCJtb3ZlVG8iLCJsaW5lVG8iLCJTUVJUMV8yIiwiY291bnQiLCJ0ZXh0IiwibWVhc3VyZVRleHQiLCJsaHMiLCJsIiwibGgiLCJzdHJva2VUZXh0IiwiYyIsImZpbGxUZXh0IiwiZWxlbWVudFZhbHVlIiwicG9zaXRpb25zIiwiZHJhd0NhbGxvdXQiLCJwb2ludFgiLCJwb2ludFkiLCJjYWxsb3V0IiwiY2FsbG91dFBvc2l0aW9uIiwiZGlzcGxheSIsInJlc29sdmVDYWxsb3V0UG9zaXRpb24iLCJpc1BvaW50SW5SYW5nZSIsInNlcGFyYXRvclN0YXJ0Iiwic2VwYXJhdG9yRW5kIiwiZ2V0Q2FsbG91dFNlcGFyYXRvckNvb3JkIiwic2lkZVN0YXJ0Iiwic2lkZUVuZCIsImdldENhbGxvdXRTaWRlQ29vcmQiLCJtYXJnaW4iLCJyb3RhdGVkUG9pbnQiLCJnZXRDYWxsb3V0U2VwYXJhdG9yQWRqdXN0Iiwic2lkZSIsImdldENhbGxvdXRTaWRlQWRqdXN0IiwiaW5jbHVkZXMiLCJyZXNvbHZlQ2FsbG91dEF1dG9Qb3NpdGlvbiIsInhQb2ludHMiLCJ5UG9pbnRzIiwiaW5kZXgiLCJsaW1pdGVkTGluZVNjYWxlIiwieFNjYWxlSUQiLCJzdGFydFByb3AiLCJlbmRQcm9wIiwieVNjYWxlSUQiLCJzY2FsZVZhbHVlIiwic2NhbGUiLCJmYWxsYmFjayIsInBhcnNlIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsInJldHJpZXZlU2NhbGVJRCIsInNjYWxlcyIsInNjYWxlSUQiLCJjaGFyQXQiLCJheGVzIiwidmFsdWVzIiwiaWQiLCJnZXREaW1lbnNpb25CeVNjYWxlIiwicmV2ZXJzZSIsImdldENoYXJ0UG9pbnQiLCJjaGFydEFyZWEiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJsZWZ0IiwidG9wIiwicmVzb2x2ZUJveFByb3BlcnRpZXMiLCJyaWdodCIsImJvdHRvbSIsInhEaW0iLCJnZXRDaGFydERpbWVuc2lvbkJ5U2NhbGUiLCJ4TWluIiwieE1heCIsInlEaW0iLCJ5TWluIiwieU1heCIsInJlc29sdmVQb2ludFByb3BlcnRpZXMiLCJhZGp1c3RDZW50ZXJYIiwiYWRqdXN0Q2VudGVyWSIsImdldENoYXJ0Q2lyY2xlIiwicmVzb2x2ZUxpbmVQcm9wZXJ0aWVzIiwiYXJlYSIsInJlc29sdmVGdWxsTGluZVByb3BlcnRpZXMiLCJyZXNvbHZlTGltaXRlZExpbmVQcm9wZXJ0aWVzIiwicmVzb2x2ZUJveEFuZExhYmVsUHJvcGVydGllcyIsImluaXRQcm9wZXJ0aWVzIiwiZWxlbWVudHMiLCJvcHRpb25TY29wZSIsInJlc29sdmVMYWJlbEVsZW1lbnRQcm9wZXJ0aWVzJDEiLCJOYU4iLCJlbmRWYWx1ZSIsImlzSG9yaXpvbnRhbCIsInNjYWxlSWQiLCJkaW0iLCJjYWxjdWxhdGVYIiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjYWxjdWxhdGVZIiwiYm94T3B0cyIsImxhYmVsT3B0cyIsInBhZFN0YXJ0IiwicGFkRW5kIiwiYXZhaWxhYmxlU2l6ZSIsIm1vdmVIb29rcyIsImV2ZW50SG9va3MiLCJjb25jYXQiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJzdGF0ZSIsImxpc3RlbmVkIiwibGlzdGVuZXJzIiwibW92ZUxpc3RlbmVkIiwiYW5ub3RhdGlvbnMiLCJzY29wZSIsImNsaWNrIiwiaGFuZGxlRXZlbnQiLCJoYW5kbGVNb3ZlRXZlbnRzIiwiaGFuZGxlQ2xpY2tFdmVudHMiLCJwcmV2aW91cyIsImhvdmVyZWQiLCJjb250ZXh0IiwiY2hhbmdlZCIsImRpc3BhdGNoTW92ZUV2ZW50cyIsImNoZWNrRWxlbWVudHMiLCJpbmRleE9mIiwiZGlzcGF0Y2hFdmVudCIsImhhbmRsZXIiLCIkY29udGV4dCIsImVsZW1lbnRIb29rcyIsInVwZGF0ZUhvb2tzIiwiaG9va2VkIiwiaW52b2tlSG9vayIsImNhbGxiYWNrSG9vayIsImFkanVzdFNjYWxlUmFuZ2UiLCJyYW5nZSIsImdldFNjYWxlTGltaXRzIiwiY2hhbmdlU2NhbGVMaW1pdCIsImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCJ2ZXJpZnlTY2FsZU9wdGlvbnMiLCJhbm5vdGF0aW9uIiwidmVyaWZ5U2NhbGVJRHMiLCJzdWdnZXN0ZWRMaW1pdCIsInNjYWxlTGltaXREZWZpbmVkIiwic2NhbGVPcHRpb25zIiwidmVyaWZ5UHJvcGVydGllcyIsImNvbnNvbGUiLCJ3YXJuIiwicHJvcCIsInNjYWxlSURPcHRpb24iLCJsaW1pdHMiLCJORUdBVElWRV9JTkZJTklUWSIsInVwZGF0ZUxpbWl0cyIsInByb3BzIiwicmF3IiwiQm94QW5ub3RhdGlvbiIsIm1vdXNlWCIsIm1vdXNlWSIsImRyYXciLCJyZXNvbHZlRWxlbWVudFByb3BlcnRpZXMiLCJ1bmRlZmluZWQiLCJkcmF3VGltZSIsImZhbWlseSIsIndlaWdodCIsInoiLCJkZWZhdWx0Um91dGVzIiwiZGVzY3JpcHRvcnMiLCJfZmFsbGJhY2siLCJEb3VnaG51dExhYmVsQW5ub3RhdGlvbiIsImRyYXdCYWNrZ3JvdW5kIiwiX2ZpdFJhdGlvIiwibWV0YSIsImdldERhdGFzZXRNZXRhIiwiY29udHJvbGxlck1ldGEiLCJnZXRDb250cm9sbGVyTWV0YSIsImdldEZpdFJhdGlvIiwiYm94U2l6ZSIsImF1dG9IaWRlIiwic3BhY2luZyIsImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCJjb250cm9sbGVyIiwiaXNDb250cm9sbGVyVmlzaWJsZSIsImRhdGEiLCJpbm5lclJhZGl1cyIsImNpcmN1bWZlcmVuY2UiLCJoaWRkZW4iLCJnZXREYXRhVmlzaWJpbGl0eSIsIm9mZnNldFgiLCJvZmZzZXRZIiwic3F1YXJlIiwic3BhY2UiLCJfcmFkaXVzIiwiX2NvdW50ZXJjbG9ja3dpc2UiLCJhbmdsZXMiLCJnZXRBbmdsZXMiLCJfY2VudGVyWCIsIl9jZW50ZXJZIiwiaHlwbyIsInNxcnQiLCJ5azIiLCJyMiIsImRlbHRhIiwiX3N0YXJ0QW5nbGUiLCJfZW5kQW5nbGUiLCJMYWJlbEFubm90YXRpb24iLCJ2aXNpYmxlIiwiX3Zpc2libGUiLCJnZXRMYWJlbFNpemUiLCJoQm9yZGVyV2lkdGgiLCJwb2ludEluTGluZSIsInAxIiwicDIiLCJ0IiwiaW50ZXJwb2xhdGVYIiwiYWJzIiwiaW50ZXJwb2xhdGVZIiwic3FyIiwidiIsInJhbmdlTGltaXQiLCJjb29yZEluQ3VydmUiLCJjcCIsInBvaW50SW5DdXJ2ZSIsImNvb3JkQW5nbGVJbkN1cnZlIiwiYW5nbGVJbkN1cnZlIiwiYXRhbjIiLCJMaW5lQW5ub3RhdGlvbiIsInBhdGgiLCJteCIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwibXkiLCJpc1BvaW50SW5TdHJva2UiLCJpc09uTGFiZWwiLCJlcHNpbG9uIiwiaW50ZXJzZWN0cyIsImluQXhpc1JhbmdlIiwiY3VydmUiLCJkcmF3Q3VydmUiLCJzdGFydE9wdHMiLCJlbmRPcHRzIiwic3RhcnRBZGp1c3QiLCJlbmRBZGp1c3QiLCJnZXRBcnJvd0hlYWRzIiwiZHJhd0Fycm93SGVhZCIsImluc2lkZSIsImlzTGluZUluQXJlYSIsImxpbWl0TGluZVRvQXJlYSIsImdldENvbnRyb2xQb2ludCIsImxhYmVsUHJvcGVydGllcyIsInJlc29sdmVMYWJlbEVsZW1lbnRQcm9wZXJ0aWVzIiwiYXJyb3dIZWFkc0RlZmF1bHRzIiwiYXJyb3dIZWFkcyIsImFzc2lnbiIsImNvbnRyb2xQb2ludCIsImxpbWl0UG9pbnRUb0FyZWEiLCJ4MSIsInkxIiwiZHgiLCJkeSIsImxlblNxIiwieHgiLCJ5eSIsInRleHRTaXplIiwiY2FsY3VsYXRlTGFiZWxQb3NpdGlvbiIsImNhbGN1bGF0ZUF1dG9Sb3RhdGlvbiIsInNpemVzIiwicm90YXRlZFNpemUiLCJjYWxjdWxhdGVUIiwicHQiLCJ4Q29vcmRpbmF0ZVNpemVzIiwieUNvb3JkaW5hdGVTaXplcyIsImFkanVzdExhYmVsQ29vcmRpbmF0ZSIsInNwYWNlQXJvdW5kIiwiY2FsY3VsYXRlVEFkanVzdCIsImxpbmVTaXplIiwibGluZVciLCJsaW5lSCIsInIiLCJjb29yZGluYXRlIiwibGFiZWxTaXplcyIsImhhbGZTaXplIiwiYXJyb3dTdGFydE9wdHMiLCJhcnJvd0VuZE9wdHMiLCJnZXRMaW5lQWRqdXN0IiwiYXJyb3dPcHRzIiwib2Zmc2V0IiwiYXJyb3dPZmZzZXRYIiwiZHJhd0Fycm93SGVhZE9uQ3VydmUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJwcyIsInBlIiwiUGF0aDJEIiwicXVhZHJhdGljQ3VydmVUbyIsIkVsbGlwc2VBbm5vdGF0aW9uIiwicG9pbnRJbkVsbGlwc2UiLCJwIiwieFJhZGl1cyIsInlSYWRpdXMiLCJjb3NBbmdsZSIsInNpbkFuZ2xlIiwiUG9pbnRBbm5vdGF0aW9uIiwiUG9seWdvbkFubm90YXRpb24iLCJwb2ludElzSW5Qb2x5Z29uIiwiYXhpc1BvaW50cyIsImJZIiwiYlgiLCJmaXJzdCIsImVsIiwic2lkZXMiLCJlbFByb3BzIiwiYnVpbGRQb2ludEVsZW1lbnQiLCJwb2ludHMiLCJpc0luc2lkZSIsIkEiLCJCIiwiYW5ub3RhdGlvblR5cGVzIiwiZGVzY3JpYmUiLCJkaXJlY3RVcGRhdGVyIiwidXBkYXRlIiwiaG9va3MkMSIsInJlc29sdmUiLCJvcHREZWZzIiwicmVzb2x2ZU9iaiIsImlzSW5kZXhhYmxlIiwicmVzb2x2ZVR5cGUiLCJ1cGRhdGVFbGVtZW50cyIsImFuaW1hdGlvbnMiLCJyZXNvbHZlQW5pbWF0aW9ucyIsInJlc3luY0VsZW1lbnRzIiwiYW5ub3RhdGlvbk9wdGlvbnMiLCJnZXRPckNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlciIsInNldENvbnRleHQiLCJnZXRDb250ZXh0Iiwic2tpcCIsInRvU2tpcCIsInVwZGF0ZVN1YkVsZW1lbnRzIiwicmVzb2x2ZUFubm90YXRpb25PcHRpb25zIiwiYW5pbU9wdHMiLCJtYWluRWxlbWVudCIsInN1YkVsZW1lbnRzIiwiZGVmaW5pdGlvbiIsInN1YkVsZW1lbnQiLCJzdWJSZXNvbHZlciIsIm92ZXJyaWRlIiwiZWxlbWVudENsYXNzIiwiZGVmcyIsImNyZWF0ZSIsImFkZCIsInNwbGljZSIsIkFycmF5IiwidmVyc2lvbiIsImNoYXJ0U3RhdGVzIiwiaXNOb3REb3VnaG51dExhYmVsIiwiYmVmb3JlUmVnaXN0ZXIiLCJhZnRlclJlZ2lzdGVyIiwicmVnaXN0ZXIiLCJhZnRlclVucmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwiYmVmb3JlSW5pdCIsImJlZm9yZVVwZGF0ZSIsImFyZ3MiLCJhZnRlckRhdGFMaW1pdHMiLCJhZnRlclVwZGF0ZSIsImJlZm9yZURhdGFzZXRzRHJhdyIsIl9hcmdzIiwiY2xpcCIsImFmdGVyRGF0YXNldHNEcmF3IiwiYmVmb3JlRGF0YXNldERyYXciLCJiZWZvcmVEcmF3IiwiYWZ0ZXJEcmF3IiwiYmVmb3JlRXZlbnQiLCJhZnRlckRlc3Ryb3kiLCJkZWxldGUiLCJnZXRBbm5vdGF0aW9ucyIsIl9nZXRBbm5vdGF0aW9uRWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsIm51bWJlcnMiLCJjb21tb24iLCJfaW5kZXhhYmxlIiwiX3NjcmlwdGFibGUiLCJfYWxsS2V5cyIsIm9wdHMiLCJhZGRpdGlvbmFsT3B0aW9uU2NvcGVzIiwiY2FsbGVyIiwiZHJhd2FibGVFbGVtZW50cyIsImdldERyYXdhYmxlRWxlbWVudHMiLCJkcmF3RWxlbWVudCIsIm1haW4iLCJzdWIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js\n");

/***/ })

};
;